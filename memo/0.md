# Assertion 単体試験 簡易ツール

　テスト結果を次のように一覧したい。HTML画面とconsoleで。

```
単体テスト結果 PP% NN件
例外 E件
失敗 F件
保留 H件
成功 S件
```

* ブラウザで実行できること（Node.js不要）
* EMS不要で実行できること（`<script type="module">`＋`import`でないと使えないのは困る）
* テスト結果が一目で判ること（成否）
    * テスト件数が一目で判ること（数）
        * テスト結果の内容が一目で判ること（色、字）
            * 成功: 緑
            * 失敗: 赤
            * 例外: 青
            * 保留: 灰
    * 修正すべき箇所が一目で判ること
        * 問題種別: 失敗／例外
        * 問題箇所のファイルパスと行列位置
    * ダークモードに対応すること
* テスト結果が真／偽／例外のいずれか期待値を定義できること
* テストしたい内容を式で書けること

```javascript
eqTrue(true);      // 成功+1
eqTrue(false);     // 失敗+1
eqTrue(()=>true);  // 成功+1
eqTrue(()=>false); // 失敗+1
eqTrue(()=>{throw new Error()}) // 例外+1
eqTrue(async()=>true); // 保留+1のち保留-1し最後に成功+1
```

# 既存自作Assertion不満一覧

* 最初に`cont a = new Assertion()`せねばならない
* 最後に`a.fin()`を呼び出さねばならない
* 引数テストパターンの実装を配列渡すだけで実装できない（エラーテスト時も同じ）

# 改善案

```javascript
const a = new Assertion(); // これがなくても動作させたい
a.t();
a.f();
a.e();
a.fin(); // これがなくてもasync()なテスト実行完了を待機してくれる仕組みをどうにかして作る。
```
```javascript
a.t(true);  // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(false); // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(()=>{throw new Error()}); // 例外カウントされる
a.t(()=>true);
a.t(async()=>true);

// 以下は期待値パターンがないため場合によっては使えない。もっと使いやすいインタフェースはないか？
a.t(()=>[引数パターン1,引数パターン2], (...args)=>true); // 引数パターン一つあたり値が一つだけの場合はこちらが使える（もし全部配列なら以下と区別がつかなくなるので注意）
a.t(()=>[[引数パターン1],[引数パターン2]], (...args)=>true); 
a.t(async()=>[引数パターン1,引数パターン2], (...args)=>true);
a.t(async()=>[[引数パターン1],[引数パターン2]], (...args)=>true); 
a.t(()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.t(()=>[[引数パターン1],[引数パターン2]], async(...args)=>true); 
a.t(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.t(async()=>[[引数パターン1],[引数パターン2]], async(...args)=>true); 
```
```javascript
a.f(true);  // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.f(false); // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(()=>{throw new Error()}); // 例外カウントされる
a.f(()=>false);
a.f(async()=>false);

// 以下は期待値パターンがないため場合によっては使えない。もっと使いやすいインタフェースはないか？
a.f(()=>[引数パターン1,引数パターン2], (...args)=>false); // 引数パターン一つあたり値が一つだけの場合はこちらが使える（もし全部配列なら以下と区別がつかなくなるので注意）
a.f(()=>[[引数パターン1],[引数パターン2]], (...args)=>false)
a.f(async()=>[引数パターン1,引数パターン2], (...args)=>false);
a.f(async()=>[[引数パターン1],[引数パターン2]], (...args)=>false)
a.f(()=>[引数パターン1,引数パターン2], async(...args)=>false);
a.f(()=>[[引数パターン1],[引数パターン2]], async(...args)=>false)
a.f(async()=>[引数パターン1,引数パターン2], async(...args)=>false);
a.f(async()=>[[引数パターン1],[引数パターン2]], async(...args)=>false)
```
```javascript
a.e(Error, `message`, ()=>{throw Error(`message`)});
a.e(Error, `message`, (()=>[引数パターン1,引数パターン2], (...args)=>{throw Error(`message`)});
a.e(Error, `message`, (()=>[[引数パターン1],[引数パターン2]], (...args)=>{throw Error(`message`)});

// 以下パターンも追加したい
a.e(new Error(`message`), ()=>{throw Error(`message`)});
a.e(Error, /^mes/, ()=>{throw Error(`message`)}); // 文字列でなく正規表現でメッセージ一致確認する
```

　尚、次のように異なる複数のテストを一つのメソッドで一括実行することはしない。理由はテスト問題発生時にその箇所が解りにくくなるから。問題発生コード行数はこのメソッドを呼び出した行数になるが、引数で渡した全テストが同じ行数を返してしまう。これではどのテストに問題があったか特定しづらい。よってこの方法は提供しない。

```javascript
a.ts(
    true,
    false,
    ()=>true,
    ()=>false,
    ()=>{throw new Error('message')},
    async()=>true,
    async()=>false,
    async()=>{throw new Error('message')},
    ...,
);
a.fs(上記に同じ);
```

　では、引数パターンを複数指定して一つのテストにまとめるのはどうか。これならテスト内容は一つにできるから、どのテストで問題があったか判別しやすいはず。

```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    (...args)=>true,
);
```
```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    ()=>[期待値パターン1,期待値パターン2], // [(...args)=>true, (...args)=>false]
);
// このパターンはa.t();をそれぞれ一個ずつ書くのと同じ。先述の通り異なる複数のテストを一箇所に書くと問題箇所の特定が困難になる問題があるので避けるべき。
```

* 引数パターン
    * 結果がどれも同じになる場合
    * 結果がそれぞれ異なる場合
        * 結果が同じ式で表現できる場合（引数を変数として同一の式を創れば異なる結果を同じ式で統一できる場合）

　上記はつまり、複数の引数パターンがあれど、引数を変数として同一の式で真偽判定できる場合を意味する。つまり以下の場合のみ存在意義がある。

```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    (...args)=>true,
);
```

　あとは結果が真／偽／例外のいずれかであるかを指定し区別できれば良さそう。つまり以下のようなメソッドを新設する価値がありそう。

```javascript
a.tc(()=>[引数パターン1,引数パターン2], (...args)=>true);
a.fc(()=>[引数パターン1,引数パターン2], (...args)=>true);
a.fc(Error, 'message', ()=>[引数パターン1,引数パターン2], (...args)=>true);
```

　式でなく単純な値でも渡せるようにしたい。それが可能なのは引数パターンだけ。テストケースは関数式で書かねばならない。引数が必要だから。

```javascript
a.tc([引数パターン1,引数パターン2], (...args)=>true);
a.fc([引数パターン1,引数パターン2], (...args)=>true);
a.ec(Error, 'message', [引数パターン1,引数パターン2], (...args)=>true);
```

　引数パターン生成とテストケースは任意で`async`も使えるようにしたい。テストケースで`async`があれば実行時は完了までの間一時的に保留される。

```javascript
a.tc(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.fc(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.ec(Error, 'message', async()=>[引数パターン1,引数パターン2], async(...args)=>true);
```

## actual

　実際値を複数返したい場合がある。以下のように。

```javascript
a.t(()=>true);                // テスト成功
a.t(()=>[true, true]);        // テスト成功
a.t(()=>[true, false, true]); // テスト失敗
```

　従来のテストコードでは以下のように書いていた。

```javascript
a.t(()=>{
    const someArgs = [0, 'A'];
    const ins = new SomeClass(...someArgs);
    return 0===ins.a && 1===ins.b && 9===ins.c;
});
```

　ここでテスト失敗した時、`a`,`b`どちらの式が失敗したか不明だったので、以下のようにコンソール出力していた。

```javascript
a.t(()=>{
    const someArgs = [0, 'A'];
    const ins = new SomeClass(...someArgs);
    console.log(0===ins.a, 1===ins.b, 9===ins.c);
    return 0===ins.a && 1===ins.b && 9===ins.c;
});
```

　そこで次のようにできないか。

```javascript
a.t(()=>{
    const someArgs = [0, 'A'];
    const ins = new SomeClass(...someArgs);
    return [0===ins.a, 1===ins.b, 9===ins.c];
});
```

```
真であるべき所が偽です。
対象id:1
コード:...
期待値idx:2
```

　だがこれでも、`9===inc.c`の部分が問題であるということが判り辛い。

　できれば以下のようなエラーメッセージにして欲しい。

```
真であるべき所が偽です。
対象id:1
コード:...
期待idx:2, 値:9, 実際値:3
```

　できればテストコードの部分文字列をそのまま抽出したい。

```
真であるべき所が偽です。
対象id: 1
コード: ...
期待不正: idx:2, コード:9===ins.c, ins.c:3
```

　だが、これを実現するには次の課題がある。

* `9===ins.c`コード文字列抽出
    * テストコード関数を文字列化して、`return`や`()=>`などのキーワードから頑張って抽出する
    * `[()=>0===ins.a, ()=>1===ins.b, ()=>9===ins.c]`のように条件式一つずつを式にする（冗長すぎて書きたくない）

　もっと簡単な方法で実装したい。以下なら雑に実装できそう。但し、オブジェクト内容から対象期待idxのプロパティを人力で参照せねばならないためノイズが多い。しかもオブジェクト内容は`console.log`なら簡単に表示できるが、HTMLではネスト構造が多数あるため大変。

```
真であるべき所が偽です。
対象id: 1
コード: ...
期待不正: idx:2, ins: {オブジェクト内容展開}
```

　インスタンス確認用メソッドを用意すれば解決か？

```javascript
bb.ins([SomeClass, [0, 'A']], (a,ins)=>{
    // 任意メソッドを実装してもよい。
    a.p('propName', 期待値); // プロパティの値を確認する
    a.m('methodName', [第一引数, 第二引数, ...], 期待値); // メソッドの入力と出力を確認する
    a.g('getterName', 期待値); // ゲッターの出力を確認する
    a.s('setterName', 期待値); // セッターの入力と出力を確認する
});
```
```
インスタンスのプロパティが期待値と異なります。
行数: N （対象id: 1）
コード: a.p('propName', 期待値);
プロパティ名: propName
期待値: 期待値
実際値: 実際値
```

```javascript
bb.ins([SomeClass, [0, 'A']], (a,ins)=>{
    // 任意メソッドを実装してもよい。
    ins.someMethod(任意引数);

    // 指定名のプロパティ、メソッド、ゲッター、セッターが存在することを確認する
    a.p('propName');   // プロパティが存在することを確認する
    a.m('methodName'); // メソッドが存在することを確認する
    a.g('getterName'); // ゲッターが存在することを確認する
    a.s('setterName'); // セッターが存在することを確認する

    // 指定名の出力結果を確認する
    a.p('propName', 期待値); // プロパティの値を確認する
    a.m('methodName', [第一引数, 第二引数, ...], 期待値); // メソッドの入力と出力を確認する
    a.g('getterName', 期待値); // ゲッターの出力を確認する
    a.s('setterName', 期待値); // セッターの入力と出力を確認する
});
```

```javascript
bb.fn();    // 指定した関数名、引数を渡してその結果を確認する

bb.cls(); // Class内でstatic定義された要素を確認する
bb.ins(); // コンストラクタを実行する(new Cls(...args))。instanceof確認する。
bb.met(); // インスタンスが持つ指定メソッドを、指定引数で実行した戻り値を確認する。または他のプロパティ、ゲッターの値を確認する。
bb.get(); // ゲッターの戻り値を確認する。または他のプロパティ、ゲッターの値を確認する。
bb.set(); // セッターに値をセットしてその結果を確認する。。または他のプロパティ、ゲッターの値を確認する。
bb.var(); // インスタンス変数（プロパティ、フィールド）の値を確認する。

bb.obj();   // 指定した値が[object Object]か確認する。所有キー名や、その値と型を確認する。
bb.ary();   // 指定した値が[object Array]か確認する。所有`length`、各index値とそれに応じた値や型を確認する。
bb.map();   // 指定した値が[object Map]か確認する。所有`length`、各index値とそれに応じた値や型を確認する。
bb.set();   // 指定した値が[object Set]か確認する。所有`length`、各index値とそれに応じた値や型を確認する。
bb.u8a();   //  指定した値が[object Uint8Array]か確認する。所有`length`、各index値とそれに応じた値や型を確認する。
bb.errCls(); // 指定した値がErrorを継承したクラス(関数)か確認する
bb.errIns(); // 指定した値がErrorを継承したクラス(関数)のインスタンスか確認する
他、組込クラスやプリミティブ値に対応した確認関数を用意したい。
```
```javascript
// 関数テスト
bb.fn('関数名', [第一引数, ...], 期待値);
bb.fn('関数名', [第一引数, ...], 1);
bb.fn('関数名', [第一引数, ...], [Error, 'メッセージ']);
bb.fn('関数名', [[第一引数, ...], [第一引数, ...]], (name, args)=>期待値);
bb.fn('関数名', [[第一引数, ...], [第一引数, ...]], [Error, 'メッセージ']);
bb.fn('関数名', [[第一引数, ...], [第一引数, ...]], (name, args)=>[Error, 'メッセージ']);
bb.fn('関数名', (a,name)=>{
    a.a([第一引数, ...], 期待値);
    a.a([第一引数, ...], 1);
    a.a([第一引数, ...], [Error, 'メッセージ']);
    a.a([[第一引数, ...], [第一引数, ...]], 1);
    a.a([[第一引数, ...], [第一引数, ...]], [Error, 'メッセージ']);
    a.a([[第一引数, ...], [第一引数, ...]], (args)=>1);
    a.a([[第一引数, ...], [第一引数, ...]], (args)=>[Error, 'メッセージ']);
});
bb.fn(obj, '関数名', (a,o,name)=>{
    // 同上
})//
```

```javascript
// クラス存在確認
a.t('SomeClassA SomeClassB'.split(' ').every(n=>n in window)); // SomeClassA/B オブジェクトが window内に存在する
bb.has(SomeClassA, SomeClassB, ...); // 存在しなければ例外発生して中断されてしまう
bb.has('SomeClassA SomeClassB'.split(' ')); // クラス名を文字列にして渡す（わざわざ専用メソッドを用意するほどでもないか？）
```
```javascript
bb.cls(SomeClass, (a,cls)=>{
    // staticなクラス変数・クラスメソッドを確認する
    a.has('StaticVar StaticMethod'.split(' ')); // 変数・関数問わず指定名メンバを持っていることを確認する
    a.v('StaticVar', 3.14);
    a.m('StaticMethod', [メソッド第一引数, ...], 戻り値);
    a.m('StaticMethod', [メソッド第一引数, ...], [Error, 'メッセージ']);
    a.m('StaticMethod', [[メソッド第一引数, ...], [メソッド第一引数, ...]], (...args)=>戻り値); // 複数の引数パターン表記
    a.m('StaticMethod', [[メソッド第一引数, ...], [メソッド第一引数, ...]], (...args)=>[Error, 'メッセージ']);
    a.ins((a,ins)=>{...}); // コンストラクタ引数省略形
    a.ins((a,ins)=>{...}, (a,ins)=>{...}, ...); // 複数テストコード式指定
    a.ins([コンストラクタ第一引数, ...], (a,ins)=>{
        a.has('insVar someMethod someGetter someSetter'.split(' ')); // 変数・関数問わず指定名メンバを持っていることを確認する
        // コンストラクタ実行直後のインスタンス変数・メソッド・ゲッター・セッターを確認する
        a.v('insVar', 0);
        a.g('someGetter', 1);
        a.s('someSetter', 0, 1);
    });
    a.ins([コンストラクタ第一引数, ...],
        (a,ins)=>{ // 毎回コンストラクタ実行
            a.v('insVar', 0);
            a.g('someGetter', 0);
            a.s('someSetter', 0, 1);
            a.v('insVar', 1);
            a.g('someGetter', 1);
        },
        (a,ins)=>{ // 毎回コンストラクタ実行
            a.s('someSetter', 0, 2);
            a.v('insVar', 2);
            a.g('someGetter', 2);
        },
    );
    a.ins([コンストラクタ第一引数, ...], (a,ins)=>{
        // インスタンス変数・メソッド・ゲッター・セッターを確認する
        a.met('メソッド名', [メソッド第一引数, ...], return期待値);
        a.met('メソッド名', [メソッド第一引数, ...], (a,name,args,ret)=>{
            a.ret(1);
//            return ret===1;
        });
        a.met('メソッド名', (a,name)=>{
            a.a([メソッド第一引数, ...], return期待値);
            a.a([メソッド第一引数, ...], 1);
            a.a([メソッド第一引数, ...], [Error, 'メッセージ']);
            a.a([メソッド第一引数, ...], (a)=>a.ret(1));
            a.a([メソッド第一引数, ...], (a, name, args, ret)=>[Error, 'メッセージ']);
            a.a([メソッド第一引数, ...], (a, name, args, ret)=>{
                a.ret(1); // 戻り値
                // class変数・classメソッド・ins変数・insメソッド・insゲッター・insセッター
                a.cv('someClassVar', 期待値);
                a.cm('someClassMethod', [引数1,...], return期待値);
                a.v('someVar', 期待値);
                a.m('someMethod', [引数1,...], return期待値);
                a.g('someMethod', 期待値);
                a.s('someMethod', [引数1,...], return期待値);
//                return 1===ret && '0'===ins.var;  従来の左記のようなコードを上記に書き換えることでエラーの箇所やメッセージを的確な内容にできる。
            });
        });
        a.get('ゲッター名');
        a.get('ゲッター名', 期待値);
        a.set('セッター名');
        a.set('セッター名', 期待値);
        a.var('変数名');
        a.var('変数名', 期待値);
    }); 
});
```
```javascript
class Assert {
    t() {}
    f() {}
    e() {}
    c() {} // c/cls/class
    fn() {} // fn/func/function
    ce() {} // c/cls/class Error
    fe() {} // fn/func/function Error
}
class FunctionAssert extends Assert {

}
class ClassAssert extends Assert {
    has() {}
    ins() {} // i/ins/instance
}
class InstanceAssert extends Assert {
    has() {}
    met() {} // m/met/method
    get() {} // g/get/getter
    set() {} // s/set/setter
    var() {} // v/var/variable
}
class MethodAssert extends Assert {
    arg() {} // a/arg/argument
}
class MethodReturnAssert extends Assert {
    r() {} // r/ret/return
    V() {} // V/cv/ClassVariable
    M() {} // M/cm/ClassMethod
    G() {} // G/cg/ClassGetter
    S() {} // S/cs/ClassSetter
    v() {} // v/var/variable
    m() {} // m/met/method
    g() {} // g/get/getter
    s() {} // s/set/setter
}
```
```javascript
bb.met([SomeClass, [コンストラクタ第一引数, ....]], 'メソッド名', [メソッド第一引数, ...], (a,ins)=>{
    // 任意メソッドを実装してもよい。
    ins.someMethod(任意引数);

    // 指定名のプロパティ、メソッド、ゲッター、セッターが存在することを確認する
    a.p('propName');   // プロパティが存在することを確認する
    a.m('methodName'); // メソッドが存在することを確認する
    a.g('getterName'); // ゲッターが存在することを確認する
    a.s('setterName'); // セッターが存在することを確認する

    // 指定名の出力結果を確認する
    a.p('propName', 期待値); // プロパティの値を確認する
    a.m('methodName', [第一引数, 第二引数, ...], 期待値); // メソッドの入力と出力を確認する
    a.g('getterName', 期待値); // ゲッターの出力を確認する
    a.s('setterName', 期待値); // セッターの入力と出力を確認する
});
```







# 実装

```javascript
const a = new Assertion();
a.t(true);
a.t(async()=>true);
a.f(false);
a.f(async()=>false);
a.e(Error, 'message', ()=>{throw new Error(`message`)});
a.e(Error, 'message', async()=>{throw new Error(`message`)});
// a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
```

　テストケースが何個あるか不明であり、いつ定義を完了させたかも不定である。このとき、どうやって完了したか否かを判断するか。

　簡単なのは以下のように一つのメソッド内で全テストケースの定義を完了させること。このとき`a`は旧コードの`new Assertion()`インスタンスである。欠点はコードがネストすること。

```javascript
Assertion.tests((a)=>{
    a.t(true);
    a.t(async()=>true);
    a.f(false);
    a.f(async()=>false);
    a.e(Error, 'message', ()=>{throw new Error(`message`)});
    a.e(Error, 'message', async()=>{throw new Error(`message`)});
    // a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
})
```
```javascript
Unitest.assert((a)=>{
    a.t(true);
    a.t(async()=>true);
    a.f(false);
    a.f(async()=>false);
    a.e(Error, 'message', ()=>{throw new Error(`message`)});
    a.e(Error, 'message', async()=>{throw new Error(`message`)});
    // a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
});
```
```javascript
class Unitest {
    static assert(fn) {
        const a = new Assertion();
        fn(a);         // テストケースの定義
        this.#test(a); // テストケースの実行
        this.#show(a); // テストケースの表示
    }
    static #test(a) {// 全テストを実行する

    }
}
class Assertion {// Unitest.assert((a)=>{})のように利用者は外部からAssertインスタンスとして利用する
    constructor() {} // 内部で全テストケースを関数として保持する
    t() {}
    f() {}
    e() {}
    tc() {}
    fc() {}
    ec() {}
}
class Show {// テスト結果をHTMLに画面表示する（結果一覧。問題箇所一覧。）

}
```

* 単体試験(UnitTest)
    * Assertion(主張)
        * 真／偽／例外(型,メッセージ)
            * 式
                * `async`


* ソースコード上


# カバレッジ率について

　カバレッジ率は、ソースコード上において一度でも実行した部分の比率を指す。これが100%なら、少なくとも一度は全コードを実行したことになる。もし100%未満なら、まだテストコードすら書いてない部分があるはず。

　カバレッジ率の算出はJavaScript単体だけでは不可能。但しChrome v73以降なら可能。

1. Chrome v73以降を起動する
2. F12キーなどでデベロッパツールを開く
3. `︙`アイコンをクリックする
4. `その他のツール`→`カバレッジ`をクリックする
5. `カバレッジ`タブが開く
6. `⟳`アイコンをクリックする
7. ファイルごとにカバレッジ率が出る
8. ファイル名をクリックするとコードが表示され、未実行箇所の行が赤色になっている。

　これにてカバレッジ率を確認すべし。

# インスタンスメソッドのテスト

　自作クラスなど複数のメソッド等の要素をテストしたい場合がある。`new`した時の引数に応じて結果が変わる。同じ引数でテストする時、インスタンス生成コードを何度も書かねばならず、冗長なので省略したい。

```javascript
const ins = new SomeClass('someArgs');
2===ins.addOne(1);
0===ins.subOne(1);
```

　このときテストコードを複数持たせ、そのテスト前後で実行するメソッドを用意する。つまりテスト直前に実行されるコードと、テスト直後に実行されるコードを追加で用意できる。直前コードで返した値は他のメソッドの引数として受け取れる。これを利用し、直前実行コードでインスタンスを返せば、全テストコードで当該インスタンスを使用できる。

```javascript
a.test(
  ()=>各テスト直前に一度だけ実行する,
  (...args)=>各テスト直後に一度だけ実行する,
  [(...args)=>テスト１, (...args)=>テスト２, (...args)=>テスト３]);
```

　例えばSomeClassのインスタンスメソッド`addOne`,`subOne`をテストする時は以下のように書ける。真なら成功、偽や例外発生なら失敗。

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>2===ins.addOne(1), (ins)=>0===ins.subOne(1)]);
```

　上記だと期待する結果が真の場合しか定義できず`async`文脈も使えないため、次のようにすると良いか。但し冗長。

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>async()=>a.t(2===ins.addOne(1)),
   (ins)=>()=>a.e(Error, '数値を入力してください。', ()=>0===ins.subOne(null))]);
```

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>2===ins.addOne(1),
   async(ins)=>2===await ins.addOne(1),
// (ins)=>async()=>2===await ins.addOne(1),
   (ins)=>[true, 2===ins.addOne(1)],
   (ins)=>[false, 2===ins.addOne(1)],
   (ins)=>[true, ()=>2===ins.addOne(1)],
   (ins)=>[false, ()=>2===ins.addOne(1)],
   (ins)=>[true, async()=>2===ins.addOne(1)],
   (ins)=>[false, async()=>2===ins.addOne(1)],
   (ins)=>[Error, '数値を入力してください。', ()=>0===ins.subOne(null)],
   (ins)=>[new Error('数値を入力してください。'), ()=>0===ins.subOne(null)];
   (ins)=>[Error, /^数値を/, ()=>0===ins.subOne(null)]]);
   (ins)=>[Error, '数値を入力してください。', async()=>0===await ins.subOne(null)],
   (ins)=>[new Error('数値を入力してください。'), async()=>0===await ins.subOne(null)];
   (ins)=>[Error, /^数値を/, async()=>0===await ins.subOne(null)]]);
```

　上記はインスタンスやメソッドが重複することがある。

　特定のインスタンスかつ特定のメソッドのみテスト対象とする場合は以下。

```javascript
a.test(
  ()=>[SomeClass, ['someArgs'], 'addOne'], // 対象クラス、コンストラクタ引数、メソッド名
  (ins)=>ins.finalize(),
  [
    (m,ins)=>2===m(1),
    async(m,ins)=>2===await m(1),
    (m)=>[Error, '数値を入力してください。', ()=>0===m(null)],
  ]);
```

　`a.test`の引数パターンは以下。

```javascript
// ファイナライザは省略可
a.test(new SomeClass('someArgs'), [(ins)=>2===ins.addOne(1)]);
a.test([new SomeClass('someArgs'), 'addOne'], [(m,ins)=>2===m(1)]);
a.test([SomeClass, ['someArgs'], 'addOne'], [(m,ins)=>2===m(1)]);
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (m,...args)=>2===m(...args));
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], async(m,...args)=>2===m(...args));
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (ins,m,...args)=>2===m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (m,args,ins)=>2===m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], async(m,args,ins)=>2===await m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['期待値A',['メソッド引数A']], ['期待値B',['メソッド引数B']]]); // 対象メソッドaddOneがAsyncなら自動的に非同期実行する。

// 関数版
a.test(someFunction, [['期待値A', ['第一引数A', '第二引数A']], ['期待値B', ['第一引数B', '第二引数B']]]); // 期待値を固定値で指定する
a.test(someFunction, [['第一引数A', '第二引数A'], ['第一引数B', '第二引数B']], (fn, ...args)=>args[0]+1===fn(...args)); // 期待値を式で算出する（あるいはリテラル）

// 対象とするメソッドや関数の属性を確認する（expression(()=>{}アロー関数なら真), generator(*function(){yield 0}なら真), async(async function(){}なら真)）
a.fn(someFunction, 'expression async'); // async()=>{}な関数であること
Type.isFn(someFunction);   // function()を始めとしたすべての関数を対象として真を返す
Type.isDFn(someFunction);  // function()で定義された関数オブジェクトなら真を返す。D=Define
Type.isAFn(someFunction);  // async function()
Type.isGFn(someFunction);  // *function() {yield}
Type.isAGFn(someFunction); // async *function() {yield}
Type.isEFn(someFunction);  // ()=> E=Expression式。アロー関数式なら真を返す。
Type.isAEFn(someFunction); // async()=>

関数オブジェクトとアロー関数式を区別する方法は、prototypeの有無。
**function.prototypeプロパティの有無を確認する**ことです。obj.prototype !== undefinedであれば通常関数、そうでなければアロー関数（またはprototypeを持たない他の関数）と判断できます。 
```

　直前メソッドはクラスのコンストラクタと引数を返す仕様に固定してしまうと以下。汎用性を失う代わりにインスタンス以外のテストをしようとすると例外発生してくれる。テストコードの可読性が高まり、ミスを発見しやすくなる。

```javascript
a.ins(
  ()=>SomeClass, ['someArgs'],
  (...args)=>{},
  [(ins)=>async()=>a.t(2===ins.addOne(1)),
   (ins)=>()=>a.e(Error, '数値を入力してください。',()=>0===ins.subOne(null))]);
```

　グローバル関数のテストについては以下。

```javascript
a.fn(
  ()=>関数ポインタ,
  [
    ['第一引数A', '第二引数A'],
    ['第一引数B', '第二引数B']
  ],
  ['期待値A', '期待値B']);
```
```javascript
a.fn(
  ()=>関数ポインタ,
  [['期待値A', ['第一引数A', '第二引数A']],
   ['期待値B', ['第一引数B', '第二引数B']]);
```

```javascript
a.fn(()=>someFunction, [['第一引数A', '第二引数A'], ['第一引数B', '第二引数B']], ['期待値A', '期待値B']);
```
```javascript
a.fn(()=>someFunction, [[期待値A, ['第一引数A', '第二引数A']], [期待値B, ['第一引数B', '第二引数B']]);
```

　期待値を式で表現したい場合もあるはず。

```javascript
a.fn(addOne, [[-1],[0],[1],[2]], (fn, ...args)=>args[0]+1===fn(...args));
```

　引数の配列を省略したい場合もあるはず。対象関数の引数が一個だけなら以下のように省略できる。

```javascript
a.fn(addOne, [-1,0,1,2], (fn, arg)=>arg+1===fn(arg));
```


# テスト対象ファイル

　Unitestは非ESMなJSコードをテスト対象とする。このとき以下のようにHTMLでロードする必要がある。

```html
<script src="test-target.js"></script>
<script src="unitest.js"></script>
```

　これをJSコード内で簡易表現したい。以下のように。

```html
<script src="unitest.js"></script>
```
```javascript
unitest('test-target.js', (a)=>{a.t(true)});
```

　仕組みは`<script>`タグの動的生成。

```javascript
/**
 * 指定されたURLからJavaScriptファイルを動的に読み込みます。
 * @param {string} src - 読み込むJavaScriptファイルのURLパス
 * @returns {Promise<void>} スクリプトの読み込みが完了または失敗したときに解決/拒否されるPromise
 */
function loadScript(src) {
  return new Promise((resolve, reject) => {
    // 1. 新しい script タグを作成する
    const script = document.createElement('script');
    script.src = src;
    script.async = true; // 可能であれば非同期で読み込む設定

    // 2. 読み込み成功時のイベントリスナー
    script.onload = () => {
      console.log(`スクリプト ${src} が正常に読み込まれました。`);
      resolve(); // Promiseを解決する
    };

    // 3. 読み込み失敗時のイベントリスナー
    script.onerror = () => {
      const error = new Error(`スクリプト ${src} の読み込みに失敗しました。`);
      console.error(error.message);
      reject(error); // Promiseを拒否する
    };

    // 4. スクリプトをドキュメントの head または body に追加して読み込みを開始する
    document.head.appendChild(script);
  });
}

// --- 使用例 ---

async function initializeApp() {
  console.log('アプリケーション初期化開始...');

  try {
    // スクリプトの読み込みが完了するまで待機する
    await loadScript('https://example.com/path/to/your-script.js');
    console.log('スクリプトの実行が完了しました。次の処理に進みます。');

    // 読み込まれたスクリプト内で定義された関数などをここで使用できる
    // myImportedFunction(); 

  } catch (error) {
    console.error('スクリプトの読み込み中にエラーが発生しました:', error);
  }
}

// 関数を呼び出して実行を開始する
// initializeApp();
```

```javascript
await Loader.js('some.js', 'some.js');
await Loader.css('some.css', 'some.css');
await Loader.html({type:'document'/'element'/'string'/'pug'/'ejs'/'jsx'/'script'}, 'some.html', 'some.html');
await Loader.document('some.html', 'some.html');
await Loader.element('some.html', 'some.html');
await Loader.tsv('some.tsv', 'some.tsv');
await Loader.json('some.json', 'some.json');
await Loader.yaml('some.yaml', 'some.yaml');
await Loader.xml('some.xml', 'some.xml');
```
```javascript
await Loader.toHtml((Dom)=>Dom.tags.div({id:'some-id'}, Dom.tags.p('段落')));
await Loader.toSvg((Dom)=>Dom.tags.svg({id:'some-id'}, Dom.tags.circle({x:0, y:0, r:10})));
await Loader.toXml((Dom)=>Dom.tags.xml({id:'some-id'}, Dom.tags.SomeTag({x:0, y:0, r:10})));
```

　もしテスト対象ファイルに依存ファイルがあれば次のようにする。配列で渡されたパス文字列の最後がテスト対象で、それ以前が依存ファイル。

```javascript
unitest(['depence.js', 'test-target.js'], (a)=>{a.t(true)});
```

　ESM版は`import()`でテスト対象を取得したい。依存ファイルは内部で`import`表記してあるはずなので以下単一ファイルパスで済む。

```javascript
unitest('test-target.esm.js', (a, mod)=>{
    a.t('testTargetFunction' in mod);
    a.t(1===mod.testTargetFunction());
});
```

# テストダブル

英|和|概要
--|--|----
Stub|スタブ|テスト対象の引数として渡すデータのこと
Fake|フェイク|テスト対象が依存するDBなどに提供するテスト用データ（ダミーとは異なり実際に使用される）
Dummy|ダミー|引数が利用されない場合に渡す引数（どうせ利用されないから適当な奴を渡す）
Spy|スパイ|既存のテスト対象呼出を監視する（）
Mock|モック|既存のテスト対象がまだ未実装かテスト用に完全置換した別物のこと。実装内容、戻り値を完全に置換できる。メソッド呼出を記録でき引数や呼出回数を確認できる。

　スタブ、フェイク、ダミーは単なるテスト用データオブジェクト。

　スパイとモックは任意メソッドの呼出を記録する。

* `const spy = new Spy('console', 'log'); テスト実行(); spy.times(1); spy.args(第一引数, 第二引数); spy.return(undefined); spy.dispose();`
* `const mock = new Mock((...args)=>'ret'); テスト実行(第一引数, mock); mock.times(1); mock.args(第一引数, 第二引数); mock.return(undefined); mock.dispose();`

* Stub
    * File System
        * Directory
            * File
                * Meta(ファイル名、ファイル作成日時等)
                * Binary
    * HTTP Response

## スパイ

```javascript
class Spy {
    constructor(obj, prop) {
        this._ = {origin:null, context:null, target:{obj:obj, prop:prop}, result:{times:0, io:[{args:null, result:{type:'return', value:undefined}}]}};
        this.on();
    }
    on() {
        this.#valid();
        // 置換
        this._.origin = window[obj][prop];
        window[obj][prop] = this.#spy();
    }
    off() {
        // 元に戻す
        window[obj][prop] = this._.origin;
    }
    #valid() {
        // 確認
        if ('string'!==this._.obj) {throw new TypeError(`objは文字列であるべきです。`)}
        if ('string'!==this._.prop) {throw new TypeError(`propは文字列であるべきです。`)}
        if (obj in window) {throw new ReferenceError(`objはwindow内に存在するオブジェクトであるべきです。`)}
        if (prop in window[obj]) {throw new ReferenceError(`propはobj内に存在し参照できるプロパティであるべきです。`)}
    }
    // テスト対象メソッドを、戻り値や引数を保持して実行する関数に置換する
    #spy() {return Type.isAFn(this._.origin) || Type.isAGFn(this._.origin) ? this.#spyAsync() : this.#spySync();}
    #spySync() {
        return ((...args)=>{
            const io = {args:args, result:{type:Type.isGFn(this._.origin) ? 'yield' : 'return', value:this._.origin(...args)}};
            this._.result.io.push(io);
            this._.result.times++;
        });
    }
    #spyAsync() {
        return (async(...args)=>{
            const io = {args:args, result:{type:Type.isAGFn(this._.origin) ? 'yield' : 'return', value:await this._.origin(...args)}};
            this._.result.io.push(io);
            this._.result.times++;
        });
    }
}
```

## モック

# 結果表示

　次のようなことを単体テスト結果として表示したい。

1. テストの合否率・件数・種別件数
2. 問題箇所と内容
3. テスト対象と件数

## 1. テストの合否率・件数・種別件数

```
保留 P
例外 E
失敗 F
成功 S
```

## 2. 問題箇所と内容

```
要約    箇所    追跡
...     ...     ...
...     ...     ...
...     ...     ...
```
```
要約    
真が期待されている所で偽になりました。
偽が期待されている所で真になりました。
例外発生が期待されている所で発生しませんでした。
例外の型が違います。
  期待値: 型
  実際値: 型
例外のメッセージが違います。
  期待値: メッセージ
  実際値: メッセージ
例外の型もメッセージも違います。
  期待値: 型, メッセージ
  実際値: 型, メッセージ
期待値と異なります。
  期待値: 値
  実際値: 値
```
```
箇所

対象id: NNN
コード: ()=>...

対象id: NNN
コード: ()=>...
引数[N]: [第一引数, 第二引数]
```

```
追跡
/some/path/target.js:行数:列数
/some/path/target.js:行数:列数
/some/path/target.js:行数:列数
...
cause 例外Type メッセージ
/some/path/target.js:行数:列数
/some/path/target.js:行数:列数
/some/path/target.js:行数:列数
```

## 3. テスト対象と件数

　テスト対象をクラス、インスタンス、メソッド、ゲッター、セッター、変数、オブジェクト、関数に大別して件数表示する。

```
class C
  method M
  getter G
  setter S
  variable V
instance I
  method M
  getter G
  setter S
  variable V
object O
  method M
  getter G
  setter S
  variable V
function F
```
```
[C] SomeClassA NNN         SomeClassA という名前のクラスを対象としたテスト件数はNNNである。
  [V] somePropA NNN        SomeClassA という名前のクラスが持つsomePropAというクラス変数を対象としたテスト件数はNNNである。s
  [G] Var NNN              SomeClassA という名前のクラスが持つVarというゲッターを対象としたテスト件数はNNNである。
  [S] Var NNN              SomeClassA という名前のクラスが持つVarというセッターを対象としたテスト件数はNNNである。
  [M] someMethodA NNN      SomeClassA という名前のクラスが持つsomeMethodAというメソッドを対象としたテスト件数はNNNである。
    [A] [第一引数, 第二引数], 戻り値 NNN   SomeClassA という名前のクラスインスタンスが持つsomeMethodAというメソッドに左記引数を渡した時のテストケースが存在します。
    ...
  [M] someMethodB NNN      SomeClassA という名前のクラスが持つsomeMethodBというメソッドを対象としたテスト件数はNNNである。
    ...
[I] SomeClassA NNN         SomeClassA という名前のクラスインスタンスを対象としたテスト件数はNNNである。
  [V] somePropA NNN        SomeClassA という名前のクラスインスタンスが持つsomePropAというインスタンス変数を対象としたテスト件数はNNNである。s
  [G] Var NNN              SomeClassA という名前のクラスインスタンスが持つVarというゲッターを対象としたテスト件数はNNNである。
  [S] Var NNN              SomeClassA という名前のクラスインスタンスが持つVarというセッターを対象としたテスト件数はNNNである。
  [M] someMethodA NNN      SomeClassA という名前のクラスインスタンスが持つsomeMethodAというメソッドを対象としたテスト件数はNNNである。
    [A] [第一引数, 第二引数], 戻り値 NNN   SomeClassA という名前のクラスインスタンスが持つsomeMethodAというメソッドに左記引数を渡した時のテストケースが存在します。
    ...
  [M] someMethodB NNN      SomeClassA という名前のクラスインスタンスが持つsomeMethodBというメソッドを対象としたテスト件数はNNNである。
    ...
[O] SomeObjectA NNN        SomeObjectA という名前のオブジェクトを対象としたテスト件数はNNNである。
  [V] somePropA NNN        SomeObjectA という名前のオブジェクトが持つsomePropAというプロパティ変数を対象としたテスト件数はNNNである。s
  [G] Var NNN              SomeObjectA という名前のオブジェクトが持つVarというゲッターを対象としたテスト件数はNNNである。
  [S] Var NNN              SomeObjectA という名前のオブジェクトが持つVarというセッターを対象としたテスト件数はNNNである。
  [M] someMethodA NNN      SomeObjectA という名前のオブジェクトが持つsomeMethodAというメソッドを対象としたテスト件数はNNNである。
    [A] [第一引数, 第二引数], 戻り値 NNN   SomeObjectA という名前のオブジェクトが持つsomeMethodAというメソッドに左記引数を渡した時のテストケースが存在します。
    ...
  [M] someMethodB NNN      SomeObjectA という名前のオブジェクトが持つsomeMethodBというメソッドを対象としたテスト件数はNNNである。
    ...
[F] SomeFunctionA NNN      SomeFunctionA という名前の関数を対象としたテスト件数はNNNである。
  [A] [第一引数, 第二引数], 戻り値 NNN      SomeFunctionA という名前の関数に左記引数を渡した時のテストケースが存在します。
  ...
...
```

　関数やメソッドの引数パターン一覧に関しては、テストケースのヌケモレがないか俯瞰するために表示する。

* ブラックボックステスト
    * 同値分割法（1〜100の整数を入力可能な場合は有効値1,50,100のデータで3件テストする。また無効値-100,'100',200,nullなどでテストする。）
    * 境界値分析（1〜100近辺の数でテストする。0,1, 100,101 の4件）
    * デシジョンテーブル
    * 状態遷移テスト




# テスト項目の重み付け

点|ラベル|概要
--|------|----
-3|できない|物理的にテスト不能。たとえばコードの構造上テストできない等。その場合はテスト可能なコードを実装・リファクタリング・テストデータ作成等条件を整えることが必要
-2|やめるべき|副作用などがありテスト以前の問題がある（周囲の環境を破壊したり依存したり等。テスト環境を用意するのが大変すぎる）
-1|やめたほうがいい|他のテストケースで補えそうな場合
0|やらなくてもいい|テストケースが膨大であり現実的でない場合はやらないことにする
1|やったほうがいい|テストケースが膨大だとやるか否か迷う
2|やるべき|テストケースが膨大だろうと絶対やるべき

