# Assertion 単体試験 簡易ツール

　テスト結果を次のように一覧したい。HTML画面とconsoleで。

```
単体テスト結果 PP% NN件
例外 E件
失敗 F件
保留 H件
成功 S件
```

* ブラウザで実行できること（Node.js不要）
* EMS不要で実行できること（`<script type="module">`＋`import`でないと使えないのは困る）
* テスト結果が一目で判ること（成否）
    * テスト件数が一目で判ること（数）
        * テスト結果の内容が一目で判ること（色、字）
            * 成功: 緑
            * 失敗: 赤
            * 例外: 青
            * 保留: 灰
    * 修正すべき箇所が一目で判ること
        * 問題種別: 失敗／例外
        * 問題箇所のファイルパスと行列位置
    * ダークモードに対応すること
* テスト結果が真／偽／例外のいずれか期待値を定義できること
* テストしたい内容を式で書けること

```javascript
eqTrue(true);      // 成功+1
eqTrue(false);     // 失敗+1
eqTrue(()=>true);  // 成功+1
eqTrue(()=>false); // 失敗+1
eqTrue(()=>{throw new Error()}) // 例外+1
eqTrue(async()=>true); // 保留+1のち保留-1し最後に成功+1
```

# 既存自作Assertion不満一覧

* 最初に`cont a = new Assertion()`せねばならない
* 最後に`a.fin()`を呼び出さねばならない
* 引数テストパターンの実装を配列渡すだけで実装できない（エラーテスト時も同じ）

# 改善案

```javascript
const a = new Assertion(); // これがなくても動作させたい
a.t();
a.f();
a.e();
a.fin(); // これがなくてもasync()なテスト実行完了を待機してくれる仕組みをどうにかして作る。
```
```javascript
a.t(true);  // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(false); // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(()=>{throw new Error()}); // 例外カウントされる
a.t(()=>true);
a.t(async()=>true);

// 以下は期待値パターンがないため場合によっては使えない。もっと使いやすいインタフェースはないか？
a.t(()=>[引数パターン1,引数パターン2], (...args)=>true); // 引数パターン一つあたり値が一つだけの場合はこちらが使える（もし全部配列なら以下と区別がつかなくなるので注意）
a.t(()=>[[引数パターン1],[引数パターン2]], (...args)=>true); 
a.t(async()=>[引数パターン1,引数パターン2], (...args)=>true);
a.t(async()=>[[引数パターン1],[引数パターン2]], (...args)=>true); 
a.t(()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.t(()=>[[引数パターン1],[引数パターン2]], async(...args)=>true); 
a.t(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.t(async()=>[[引数パターン1],[引数パターン2]], async(...args)=>true); 
```
```javascript
a.f(true);  // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.f(false); // 例外発生時はキャッチできない（カウントされず実行時エラーになる）
a.t(()=>{throw new Error()}); // 例外カウントされる
a.f(()=>false);
a.f(async()=>false);

// 以下は期待値パターンがないため場合によっては使えない。もっと使いやすいインタフェースはないか？
a.f(()=>[引数パターン1,引数パターン2], (...args)=>false); // 引数パターン一つあたり値が一つだけの場合はこちらが使える（もし全部配列なら以下と区別がつかなくなるので注意）
a.f(()=>[[引数パターン1],[引数パターン2]], (...args)=>false)
a.f(async()=>[引数パターン1,引数パターン2], (...args)=>false);
a.f(async()=>[[引数パターン1],[引数パターン2]], (...args)=>false)
a.f(()=>[引数パターン1,引数パターン2], async(...args)=>false);
a.f(()=>[[引数パターン1],[引数パターン2]], async(...args)=>false)
a.f(async()=>[引数パターン1,引数パターン2], async(...args)=>false);
a.f(async()=>[[引数パターン1],[引数パターン2]], async(...args)=>false)
```
```javascript
a.e(Error, `message`, ()=>{throw Error(`message`)});
a.e(Error, `message`, (()=>[引数パターン1,引数パターン2], (...args)=>{throw Error(`message`)});
a.e(Error, `message`, (()=>[[引数パターン1],[引数パターン2]], (...args)=>{throw Error(`message`)});

// 以下パターンも追加したい
a.e(new Error(`message`), ()=>{throw Error(`message`)});
a.e(Error, /^mes/, ()=>{throw Error(`message`)}); // 文字列でなく正規表現でメッセージ一致確認する
```

　尚、次のように異なる複数のテストを一つのメソッドで一括実行することはしない。理由はテスト問題発生時にその箇所が解りにくくなるから。問題発生コード行数はこのメソッドを呼び出した行数になるが、引数で渡した全テストが同じ行数を返してしまう。これではどのテストに問題があったか特定しづらい。よってこの方法は提供しない。

```javascript
a.ts(
    true,
    false,
    ()=>true,
    ()=>false,
    ()=>{throw new Error('message')},
    async()=>true,
    async()=>false,
    async()=>{throw new Error('message')},
    ...,
);
a.fs(上記に同じ);
```

　では、引数パターンを複数指定して一つのテストにまとめるのはどうか。これならテスト内容は一つにできるから、どのテストで問題があったか判別しやすいはず。

```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    (...args)=>true,
);
```
```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    ()=>[期待値パターン1,期待値パターン2], // [(...args)=>true, (...args)=>false]
);
// このパターンはa.t();をそれぞれ一個ずつ書くのと同じ。先述の通り異なる複数のテストを一箇所に書くと問題箇所の特定が困難になる問題があるので避けるべき。
```

* 引数パターン
    * 結果がどれも同じになる場合
    * 結果がそれぞれ異なる場合
        * 結果が同じ式で表現できる場合（引数を変数として同一の式を創れば異なる結果を同じ式で統一できる場合）

　上記はつまり、複数の引数パターンがあれど、引数を変数として同一の式で真偽判定できる場合を意味する。つまり以下の場合のみ存在意義がある。

```javascript
a.cases(
    ()=>[引数パターン1,引数パターン2],
    (...args)=>true,
);
```

　あとは結果が真／偽／例外のいずれかであるかを指定し区別できれば良さそう。つまり以下のようなメソッドを新設する価値がありそう。

```javascript
a.tc(()=>[引数パターン1,引数パターン2], (...args)=>true);
a.fc(()=>[引数パターン1,引数パターン2], (...args)=>true);
a.fc(Error, 'message', ()=>[引数パターン1,引数パターン2], (...args)=>true);
```

　式でなく単純な値でも渡せるようにしたい。それが可能なのは引数パターンだけ。テストケースは関数式で書かねばならない。引数が必要だから。

```javascript
a.tc([引数パターン1,引数パターン2], (...args)=>true);
a.fc([引数パターン1,引数パターン2], (...args)=>true);
a.ec(Error, 'message', [引数パターン1,引数パターン2], (...args)=>true);
```

　引数パターン生成とテストケースは任意で`async`も使えるようにしたい。テストケースで`async`があれば実行時は完了までの間一時的に保留される。

```javascript
a.tc(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.fc(async()=>[引数パターン1,引数パターン2], async(...args)=>true);
a.ec(Error, 'message', async()=>[引数パターン1,引数パターン2], async(...args)=>true);
```

# 実装

```javascript
const a = new Assertion();
a.t(true);
a.t(async()=>true);
a.f(false);
a.f(async()=>false);
a.e(Error, 'message', ()=>{throw new Error(`message`)});
a.e(Error, 'message', async()=>{throw new Error(`message`)});
// a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
```

　テストケースが何個あるか不明であり、いつ定義を完了させたかも不定である。このとき、どうやって完了したか否かを判断するか。

　簡単なのは以下のように一つのメソッド内で全テストケースの定義を完了させること。このとき`a`は旧コードの`new Assertion()`インスタンスである。欠点はコードがネストすること。

```javascript
Assertion.tests((a)=>{
    a.t(true);
    a.t(async()=>true);
    a.f(false);
    a.f(async()=>false);
    a.e(Error, 'message', ()=>{throw new Error(`message`)});
    a.e(Error, 'message', async()=>{throw new Error(`message`)});
    // a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
})
```
```javascript
Unitest.assert((a)=>{
    a.t(true);
    a.t(async()=>true);
    a.f(false);
    a.f(async()=>false);
    a.e(Error, 'message', ()=>{throw new Error(`message`)});
    a.e(Error, 'message', async()=>{throw new Error(`message`)});
    // a.fin();を呼び出さずとも完了か否か判断できるようにしたい。
});
```
```javascript
class Unitest {
    static assert(fn) {
        const a = new Assertion();
        fn(a);         // テストケースの定義
        this.#test(a); // テストケースの実行
        this.#show(a); // テストケースの表示
    }
    static #test(a) {// 全テストを実行する

    }
}
class Assertion {// Unitest.assert((a)=>{})のように利用者は外部からAssertインスタンスとして利用する
    constructor() {} // 内部で全テストケースを関数として保持する
    t() {}
    f() {}
    e() {}
    tc() {}
    fc() {}
    ec() {}
}
class Show {// テスト結果をHTMLに画面表示する（結果一覧。問題箇所一覧。）

}
```

* 単体試験(UnitTest)
    * Assertion(主張)
        * 真／偽／例外(型,メッセージ)
            * 式
                * `async`


* ソースコード上


# カバレッジ率について

　カバレッジ率は、ソースコード上において一度でも実行した部分の比率を指す。これが100%なら、少なくとも一度は全コードを実行したことになる。もし100%未満なら、まだテストコードすら書いてない部分があるはず。

　カバレッジ率の算出はJavaScript単体だけでは不可能。但しChrome v73以降なら可能。

1. Chrome v73以降を起動する
2. F12キーなどでデベロッパツールを開く
3. `︙`アイコンをクリックする
4. `その他のツール`→`カバレッジ`をクリックする
5. `カバレッジ`タブが開く
6. `⟳`アイコンをクリックする
7. ファイルごとにカバレッジ率が出る
8. ファイル名をクリックするとコードが表示され、未実行箇所の行が赤色になっている。

　これにてカバレッジ率を確認すべし。

# インスタンスメソッドのテスト

　自作クラスなど複数のメソッド等の要素をテストしたい場合がある。`new`した時の引数に応じて結果が変わる。同じ引数でテストする時、インスタンス生成コードを何度も書かねばならず、冗長なので省略したい。

```javascript
const ins = new SomeClass('someArgs');
2===ins.addOne(1);
0===ins.subOne(1);
```

　このときテストコードを複数持たせ、そのテスト前後で実行するメソッドを用意する。つまりテスト直前に実行されるコードと、テスト直後に実行されるコードを追加で用意できる。直前コードで返した値は他のメソッドの引数として受け取れる。これを利用し、直前実行コードでインスタンスを返せば、全テストコードで当該インスタンスを使用できる。

```javascript
a.test(
  ()=>各テスト直前に一度だけ実行する,
  (...args)=>各テスト直後に一度だけ実行する,
  [(...args)=>テスト１, (...args)=>テスト２, (...args)=>テスト３]);
```

　例えばSomeClassのインスタンスメソッド`addOne`,`subOne`をテストする時は以下のように書ける。真なら成功、偽や例外発生なら失敗。

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>2===ins.addOne(1), (ins)=>0===ins.subOne(1)]);
```

　上記だと期待する結果が真の場合しか定義できず`async`文脈も使えないため、次のようにすると良いか。但し冗長。

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>async()=>a.t(2===ins.addOne(1)),
   (ins)=>()=>a.e(Error, '数値を入力してください。', ()=>0===ins.subOne(null))]);
```

```javascript
a.test(
  ()=>new SomeClass('someArgs'),
  (ins)=>{ins.finalize()},
  [(ins)=>2===ins.addOne(1),
   async(ins)=>2===await ins.addOne(1),
// (ins)=>async()=>2===await ins.addOne(1),
   (ins)=>[true, 2===ins.addOne(1)],
   (ins)=>[false, 2===ins.addOne(1)],
   (ins)=>[true, ()=>2===ins.addOne(1)],
   (ins)=>[false, ()=>2===ins.addOne(1)],
   (ins)=>[true, async()=>2===ins.addOne(1)],
   (ins)=>[false, async()=>2===ins.addOne(1)],
   (ins)=>[Error, '数値を入力してください。', ()=>0===ins.subOne(null)],
   (ins)=>[new Error('数値を入力してください。'), ()=>0===ins.subOne(null)];
   (ins)=>[Error, /^数値を/, ()=>0===ins.subOne(null)]]);
   (ins)=>[Error, '数値を入力してください。', async()=>0===await ins.subOne(null)],
   (ins)=>[new Error('数値を入力してください。'), async()=>0===await ins.subOne(null)];
   (ins)=>[Error, /^数値を/, async()=>0===await ins.subOne(null)]]);
```

　上記はインスタンスやメソッドが重複することがある。

　特定のインスタンスかつ特定のメソッドのみテスト対象とする場合は以下。

```javascript
a.test(
  ()=>[SomeClass, ['someArgs'], 'addOne'], // 対象クラス、コンストラクタ引数、メソッド名
  (ins)=>ins.finalize(),
  [
    (m,ins)=>2===m(1),
    async(m,ins)=>2===await m(1),
    (m)=>[Error, '数値を入力してください。', ()=>0===m(null)],
  ]);
```

　`a.test`の引数パターンは以下。

```javascript
// ファイナライザは省略可
a.test(new SomeClass('someArgs'), [(ins)=>2===ins.addOne(1)]);
a.test([new SomeClass('someArgs'), 'addOne'], [(m,ins)=>2===m(1)]);
a.test([SomeClass, ['someArgs'], 'addOne'], [(m,ins)=>2===m(1)]);
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (m,...args)=>2===m(...args));
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], async(m,...args)=>2===m(...args));
// a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (ins,m,...args)=>2===m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], (m,args,ins)=>2===m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['メソッド引数A'], ['メソッド引数B']], async(m,args,ins)=>2===await m(...args));
a.test([SomeClass, ['someArgs'], 'addOne'], [['期待値A',['メソッド引数A']], ['期待値B',['メソッド引数B']]]); // 対象メソッドaddOneがAsyncなら自動的に非同期実行する。

// 関数版
a.test(someFunction, [['期待値A', ['第一引数A', '第二引数A']], ['期待値B', ['第一引数B', '第二引数B']]]); // 期待値を固定値で指定する
a.test(someFunction, [['第一引数A', '第二引数A'], ['第一引数B', '第二引数B']], (fn, ...args)=>args[0]+1===fn(...args)); // 期待値を式で算出する（あるいはリテラル）

// 対象とするメソッドや関数の属性を確認する（expression(()=>{}アロー関数なら真), generator(*function(){yield 0}なら真), async(async function(){}なら真)）
a.fn(someFunction, 'expression async'); // async()=>{}な関数であること
Type.isFn(someFunction);   // function()を始めとしたすべての関数を対象として真を返す
Type.isDFn(someFunction);  // function()で定義された関数オブジェクトなら真を返す。D=Define
Type.isAFn(someFunction);  // async function()
Type.isGFn(someFunction);  // *function() {yield}
Type.isAGFn(someFunction); // async *function() {yield}
Type.isEFn(someFunction);  // ()=> E=Expression式。アロー関数式なら真を返す。
Type.isAEFn(someFunction); // async()=>

関数オブジェクトとアロー関数式を区別する方法は、prototypeの有無。
**function.prototypeプロパティの有無を確認する**ことです。obj.prototype !== undefinedであれば通常関数、そうでなければアロー関数（またはprototypeを持たない他の関数）と判断できます。 
```

　直前メソッドはクラスのコンストラクタと引数を返す仕様に固定してしまうと以下。汎用性を失う代わりにインスタンス以外のテストをしようとすると例外発生してくれる。テストコードの可読性が高まり、ミスを発見しやすくなる。

```javascript
a.ins(
  ()=>SomeClass, ['someArgs'],
  (...args)=>{},
  [(ins)=>async()=>a.t(2===ins.addOne(1)),
   (ins)=>()=>a.e(Error, '数値を入力してください。',()=>0===ins.subOne(null))]);
```

　グローバル関数のテストについては以下。

```javascript
a.fn(
  ()=>関数ポインタ,
  [
    ['第一引数A', '第二引数A'],
    ['第一引数B', '第二引数B']
  ],
  ['期待値A', '期待値B']);
```
```javascript
a.fn(
  ()=>関数ポインタ,
  [['期待値A', ['第一引数A', '第二引数A']],
   ['期待値B', ['第一引数B', '第二引数B']]);
```

```javascript
a.fn(()=>someFunction, [['第一引数A', '第二引数A'], ['第一引数B', '第二引数B']], ['期待値A', '期待値B']);
```
```javascript
a.fn(()=>someFunction, [[期待値A, ['第一引数A', '第二引数A']], [期待値B, ['第一引数B', '第二引数B']]);
```

　期待値を式で表現したい場合もあるはず。

```javascript
a.fn(addOne, [[-1],[0],[1],[2]], (fn, ...args)=>args[0]+1===fn(...args));
```

　引数の配列を省略したい場合もあるはず。対象関数の引数が一個だけなら以下のように省略できる。

```javascript
a.fn(addOne, [-1,0,1,2], (fn, arg)=>arg+1===fn(arg));
```


# テスト対象ファイル

　Unitestは非ESMなJSコードをテスト対象とする。このとき以下のようにHTMLでロードする必要がある。

```html
<script src="test-target.js"></script>
<script src="unitest.js"></script>
```

　これをJSコード内で簡易表現したい。以下のように。

```html
<script src="unitest.js"></script>
```
```javascript
unitest('test-target.js', (a)=>{a.t(true)});
```

　仕組みは`<script>`タグの動的生成。

```javascript
/**
 * 指定されたURLからJavaScriptファイルを動的に読み込みます。
 * @param {string} src - 読み込むJavaScriptファイルのURLパス
 * @returns {Promise<void>} スクリプトの読み込みが完了または失敗したときに解決/拒否されるPromise
 */
function loadScript(src) {
  return new Promise((resolve, reject) => {
    // 1. 新しい script タグを作成する
    const script = document.createElement('script');
    script.src = src;
    script.async = true; // 可能であれば非同期で読み込む設定

    // 2. 読み込み成功時のイベントリスナー
    script.onload = () => {
      console.log(`スクリプト ${src} が正常に読み込まれました。`);
      resolve(); // Promiseを解決する
    };

    // 3. 読み込み失敗時のイベントリスナー
    script.onerror = () => {
      const error = new Error(`スクリプト ${src} の読み込みに失敗しました。`);
      console.error(error.message);
      reject(error); // Promiseを拒否する
    };

    // 4. スクリプトをドキュメントの head または body に追加して読み込みを開始する
    document.head.appendChild(script);
  });
}

// --- 使用例 ---

async function initializeApp() {
  console.log('アプリケーション初期化開始...');

  try {
    // スクリプトの読み込みが完了するまで待機する
    await loadScript('https://example.com/path/to/your-script.js');
    console.log('スクリプトの実行が完了しました。次の処理に進みます。');

    // 読み込まれたスクリプト内で定義された関数などをここで使用できる
    // myImportedFunction(); 

  } catch (error) {
    console.error('スクリプトの読み込み中にエラーが発生しました:', error);
  }
}

// 関数を呼び出して実行を開始する
// initializeApp();
```

```javascript
await Loader.js('some.js', 'some.js');
await Loader.css('some.css', 'some.css');
await Loader.html({type:'document'/'element'/'string'/'pug'/'ejs'/'jsx'/'script'}, 'some.html', 'some.html');
await Loader.document('some.html', 'some.html');
await Loader.element('some.html', 'some.html');
await Loader.tsv('some.tsv', 'some.tsv');
await Loader.json('some.json', 'some.json');
await Loader.yaml('some.yaml', 'some.yaml');
await Loader.xml('some.xml', 'some.xml');
```
```javascript
await Loader.toHtml((Dom)=>Dom.tags.div({id:'some-id'}, Dom.tags.p('段落')));
await Loader.toSvg((Dom)=>Dom.tags.svg({id:'some-id'}, Dom.tags.circle({x:0, y:0, r:10})));
await Loader.toXml((Dom)=>Dom.tags.xml({id:'some-id'}, Dom.tags.SomeTag({x:0, y:0, r:10})));
```

　もしテスト対象ファイルに依存ファイルがあれば次のようにする。配列で渡されたパス文字列の最後がテスト対象で、それ以前が依存ファイル。

```javascript
unitest(['depence.js', 'test-target.js'], (a)=>{a.t(true)});
```

　ESM版は`import()`でテスト対象を取得したい。依存ファイルは内部で`import`表記してあるはずなので以下単一ファイルパスで済む。

```javascript
unitest('test-target.esm.js', (a, mod)=>{
    a.t('testTargetFunction' in mod);
    a.t(1===mod.testTargetFunction());
});
```

