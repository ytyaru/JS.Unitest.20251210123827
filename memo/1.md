# テスト要素

* テスト対象（オブジェクト、プロパティ名）
* テスト条件（引数、モック、スパイ）
* テスト内容（型、値、判定内容）
* テスト実行（結果・例外発生）
* テスト結果（テスト対象、テスト件数、結果分類と件数、結果のコード箇所）

## t/f/e

　テスト結果を真偽値か例外発生の二種類だけで定義する。テストコードは本番時に使用するコードと同じように書ける反面、テスト結果ではそのテスト対象が何であるかを判別できない。エラー箇所さえ分かれば問題ないが、テスト内容が俯瞰できないため、テスト漏れがないか判断しづらい。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.t(true);
    a.t(()=>true);
    a.t(async()=>true);
    a.f(true);
    a.f(()=>true);
    a.f(async()=>true);
    a.e(Error, ()=>例外発生コード);
    a.e(new Error('エラーメッセージ'), ()=>例外発生コード);
    a.e(Error, 'エラーメッセージ', ()=>例外発生コード);
    a.e(Error, /^エラーメ/, ()=>例外発生コード);
});
```

## ts/fs/es

　複数形。単体試験において同値分割法があり、複数の値をテストする場合がよくある。このとき、入力値は複数ある。そして出力結果は入力値によって動的に算出できる。ならば次のようなAPIが欲しくなる。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.ts([[第一引数,...], [第一引数,...]], (args, i)=>{
        const res = テスト対象関数(...args);
        return res===args[i]+1;
    });
});
```

　上記は以下テストコード生成と同じである。つまりa.t()をfor()で繰り返し生成することを簡易記法化したもの。

```javascript
for (let args of [[第一引数,...], [第一引数,...]]) {
    a.t(()=>{
        const res = テスト対象関数(...args);
        return res===args[i]+1;
    });
}
```

## 複数return

　正常系テストで以下のように複数条件確認することが多々有る。このとき、どの確認が例外発生させたか、その値がいくつだったのかが不明で困る。

```javascript
a.t(()=>{
    return obj.A===1 && obj.B===2;
});
```

　そこでしばしば、以下のような出力をする。

```javascript
a.t(()=>{
    console.log(obj.A===1, obj.B===2); // 何番目がエラーになったか
    console.log(obj.A, obj.B);         // エラーになった値は何を返したのか
    return obj.A===1 && obj.B===2;
});
```

　これにて問題となる実装箇所を特定する。でも毎回このデバッグ出力コードを書くのが面倒くさい。

　そこで、以下のように真偽値の配列として返す。全部真ならテスト合格。一つでも偽なら、そのindexを返せば、何番目の条件式がエラーになったかは判明する。でも`obj`の`A`や`B`が何の値を返したかまでは不明なので、問題箇所を特定できない。

```javascript
a.t(()=>{
    return [obj.A===1, obj.B===2]; // rets.every(v=>v)が真であること。もし偽ならその箇所を返す。でも`obj`の`A`や`B`が何の値を返すかは不明のまま……
});
```

### テスト対象の指定

　テスト対象を設定すれば、その値を取得できるはず。以下のように。

```javascript
a.target(obj, 'プロパティ名', '期待値');
```

　でも期待値がオブジェクト型だった場合、そのオブジェクトが持つプロパティを確認する必要がある。さらにそのオブジェクトが持つオブジェクトと、ネストしていく必要がある。これは非常に面倒臭い。なのでそのネスト参照だけは`obj.sub.nest.prop`のように自分で書く。これならテストAPIをネストさせずに済むはず。

```javascript
a.t(()=>{
    const ret = テストしたい関数();
    a.obj(ret);                                 // retはObjectであること
    a.obj(ret, 'sub');                          // ret.subはObjectであること
    a.obj(ret.sub, 'nest');                     // ret.sub.nestはObjectであること
    a.prim(ret.sub.nest, 'propA', '期待値');    // ret.sub.nest.propAはPrimitiveであり値は'期待値'と一致すること
    a.prim(ret.sub.nest, 'propB', a=>a.within(1, 10));    // ret.sub.nest.propBはPrimitiveであり値はNumber/BigIntであり1〜10の間であること（型により確認API多数必要）
    a.obj(ret.sub.nest, 'propC', a=>a.isCls);   // ret.sub.nest.propCはObjectでありClassであること
});
```

　しかし上記のようにすると、型に応じて確認用APIが多数必要になる。たとえばNumber型なら範囲確認や、isSafeInteger、NaNなど。String型なら文字数やmatch、オブジェクト型なら自作APIやプロパティ値まで含めると式を書かねば表現できない。すると最初の問題である「どのプロパティが何の値かわからない」問題に戻ってしまう。

　テスト用APIは一切提供しないことにすると、どうなるか。すなわちテスト対象の参照値だけを返すようにする。これならテスト対象の値が何かを返せるし、テスト方法はその都度式で自由に書けるし、書かねばならない。オブジェクトを返す時はテスト式がネストすることになってしまう。

```javascript
a.t(()=>{
    const ret = テストしたい関数();
    a.obj(ret.sub.nest, 'propC', v=>v instanceof SomeClass); // テスト用APIでなく参照値が返す値だけを渡して、あとは自分で式を書くようにする
    a.obj(ret.sub.nest, 'propC', v=>{
        a.obj(v, 'propX', v=>{
            a.obj(v, 'propY', v=>{
                a.obj(v, 'propZ', v=>{...});
                return v instanceof SomeClassY;
            });
            return v instanceof SomeClassX;
        });
        return v instanceof SomeClass;
    }); // ネストしたオブジェクトの場合、テスト式もネストすることになってしまう
});
```
```javascript
a.t(()=>{
    const ins = new テストクラス();
    const ret = ins.テストしたいメソッド();
    a.obj(ret, 'sub');
    a.obj(ret.sub, 'nest');
    a.prim(ret.sub.nest, 'propA', '期待値');
    a.prim(ret.sub.nest, 'propA', v=>'number'===typeof v && 1===v);
    a.obj(ret.sub.nest, 'propB', a=>a.isIns && a.insOf(SomeClass));
});
```

　テスト対象の指定は真偽値を返す`a.t()`では実現不能。新たなAPIが要る。

## cls/fn/obj/prim

　テスト対象を明示することでテスト内容がわかりやすくなる。だが専用APIテストコードを大量に書かねばならない。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{...});
    a.fn(SomeFunction, a=>{...});
    a.obj(SomeObject, a=>{...});
    a.prim(somePrimitive, a=>{...});
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.prim(somePrimitive, a=>{
        // 型
        a.type.isBln;
        a.type.isNum;
        a.type.isInt;
        a.type.isStr;
        a.type.isSym;
        a.type.isNul;
        a.type.isUnd;
        // 値
        //   Null,Undefined,Symbol
        a.value.isNul; // typeと同じで別名
        a.value.isUnd; // typeと同じで別名
        a.value.eq(期待値); // Bln,Num,Int,Str,Sym
        //   Boolean
        a.value.isT;
        a.value.isF;
        //   Number/BigInt
        a.value.ne(この値と一致しないこと);
        a.value.l(これより小さいこと);
        a.value.g(これより大きいこと);
        a.value.le(これより小さいこと);
        a.value.ge(これより大きいこと);
        a.value.within(最小値, 最大値);
        a.value.without(最小値, 最大値);
        //   Number
        a.value.isNaN;
        a.value.isNotNaN;
        a.value.isPInf;
        a.value.isNInf;
        a.value.isNotPInf;
        a.value.isNotNInf;
        a.value.isSafeInt(期待値);
        a.value.nearEq(IEEE754誤差を考慮した比較);
        //   String
        a.value.length(バイト数);  // (最小値, 最大値)
        a.value.graphemes(文字数); // (最小値, 最大値)
        a.value.eq('完全一致する期待値');
        a.value.startsWith('前方一致する期待値');
        a.value.endsWith('後方一致する期待値');
        a.value.with('部分一致する期待値');
        a.value.match(/正規表現/);
    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.obj(SomeObject, a=>{
        a.isCls;
        a.isIns;
        a.isErrCls;
        a.isErrIns;
        a.isFnLike;
        a.isAFnLike;
        a.isGFnLike;
        a.isFn;
        a.isAFn;
        a.isGFn;
        a.isAGFn;
        a.isObjLike; // 'object'===typeof v && null!==v
        a.isObj;     // [object Object]
        a.clsOf(SomeClass);
        a.insOf(SomeClass);
        a.isAry;
        a.aryOf('number'/'ClassName');
        a.tag('Array'); // [object Array]である
        a.isD;  // Descriptor
        a.isDD; // DataDescriptor（value）
        a.isAD; // AccessorDescriptor (Getter || Setter)
        a.isG;  // Getterのみ
        a.isS;  // Setterのみ
        a.isGS; // GetterとSetterの両方ある
        a.t(()=>true); // 任意のテスト式でtrueを返すこと
        a.e(()=>true); // 任意のテスト式で例外発生すること
        a.prim('プロパティ名', a=>{}); // Object内のプロパティ
        a.obj('プロパティ名', a=>{}); // Object内のプロパティ
    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.fn(SomeFunction, a=>{
        a.a([第一引数, ...], '戻り値の期待値プリミティブ');
        a.a([第一引数, ...], a=>{
            a.prim();
            a.obj();
        });
        a.a([第一引数, a.mock(()=>{}), ...], a.spy(obj,'prop'), ..., a=>{
            a.prim();
            a.obj();
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fns(SomeFunction, a=>{
        a.s([[], [第一引数, ...], [a.mock(()=>{}), ...], ...], a.spy(obj,'prop'), ..., a=>{
            a.prim();
            a.obj();
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fe(SomeFunction, a=>{
        // 引数なし
        a.e(Error);
        a.e('メッセージ');
        a.e(/メッセ/);
        a.e(new Error('メッセージ'));
        a.e(Error, 'メッセージ');
        a.e(Error, /メッセ/);
        // 引数あり
        a.a([第一引数, ...], Error);
        a.a([第一引数, ...], 'メッセージ');
        a.a([第一引数, ...], /メッセ/);
        a.a([第一引数, ...], new Error('メッセージ'));
        a.a([第一引数, ...], Error, 'メッセージ');
        a.a([第一引数, ...], Error, /メッセ/);
        // 引数, Mock, Spyあり
        a.a([第一引数, a.mock(()=>{}), ...], a.spy(obj,'prop'), ..., a=>{
            // 戻り値の確認
            a.prim();
            a.obj();
            // Mock, Spyの確認
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fes(SomeFunction, a=>{

    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{
        
    });
    a.fn(SomeFunction, a=>{

    });
    a.obj(SomeObject, a=>{

    });
    a.prim(somePrimitive, a=>{

    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{
        
    });
    a.fn(SomeFunction, a=>{

    });
    a.obj(SomeObject, a=>{

    });
    a.prim(somePrimitive, a=>{

    });
});
```

```javascript
class 
```



# 単体試験 テストケース 作り方 ヌケモレがないか

## AI による概要

　単体テストのテストケース作成において抜け漏れを防ぐには、体系的なテスト設計技法の活用と、明確なテスト観点の設定が重要です。以下に具体的な方法を示します。 

### 1. テストケース作成の基本手順

    テスト対象の明確化: まず、どの機能やモジュールをテストするのか、その範囲と目的を明確にします。
    テスト観点の洗い出し: テスト対象の機能や仕様書から、「何をテストすべきか」という観点を洗い出します。
        機能要素: どのような機能があるか。
        入力条件: どのような入力値が許容されるか、またはされないか。
        出力結果: 入力に対してどのような結果（正常な値、エラーメッセージなど）が期待されるか。
    テスト技法の適用: 洗い出した観点に基づき、効率よく網羅的なテストケースを作成するために以下の技法を適用します。
    テストケースの記述: 「テスト対象」「テスト観点」「テスト条件」「テスト手順」「期待値」といった必要な項目を明確に記述します。 

### 2. 抜け漏れを防ぐためのテスト技法

効率的かつ網羅的にテストケースを作成するには、以下の技法を組み合わせます。 

    同値分割法: 有効な入力値の範囲をいくつかのグループ（同値クラス）に分け、各グループから代表値を選んでテストします。例えば、年齢が「0～120」歳の場合、「有効値（10歳）」と「無効値（-1歳、121歳）」のように分割します。
    境界値分析法: 同値分割した境界となる値やその前後の値をテストします。上記の例では、「0歳、1歳」「119歳、120歳」などをテストします。
    異常値分析: 仕様外の無効な値（例: マイナス値、全角文字、記号など）を入力し、適切なエラーハンドリングがされるかを確認します。
    デシジョンテーブル（決定表）: 複数の条件の組み合わせによって動作が変わる場合に、すべての組み合わせとその結果を網羅的にリストアップします。 

### 3. 網羅性チェックのための戦略

    コードカバレッジの活用: 実際にテストケースを実行し、どの程度のコードが実行されたかを測定します（行カバレッジ、分岐カバレッジなど）。これにより、テストされていないコード部分を特定し、追加のテストケースを作成できます。
    第三者によるレビュー: 作成したテストケースを他の開発者やテスターにレビューしてもらうことで、個人の先入観による抜け漏れを防げます。
    チェックリストの利用: フォームの入力項目、データベースの操作、例外処理など、一般的なテスト観点をまとめたチェックリストを用意しておくと、確認漏れを減らせます。
    過去の不具合事例を参考にする: 過去のプロジェクトで発生したバグや不具合の事例を参考に、同様の問題が発生しないようなテストケースを事前に組み込みます。 

これらの体系的なアプローチにより、単体テストにおけるテストケースの抜け漏れを大幅に減らし、ソフトウェアの品質向上につながります。 
