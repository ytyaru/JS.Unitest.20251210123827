# テスト要素

* テスト対象（オブジェクト、プロパティ名）
* テスト条件（引数、モック、スパイ）
* テスト内容（型、値、判定内容）
* テスト実行（結果・例外発生）
* テスト結果（テスト対象、テスト件数、結果分類と件数、結果のコード箇所）

## t/f/e

　テスト結果を真偽値か例外発生の二種類だけで定義する。テストコードは本番時に使用するコードと同じように書ける反面、テスト結果ではそのテスト対象が何であるかを判別できない。エラー箇所さえ分かれば最低限の問題はないが、テスト内容が俯瞰できないため、テスト漏れがないか判断しづらい。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.t(true);
    a.t(()=>true);
    a.t(async()=>true);
    a.f(true);
    a.f(()=>true);
    a.f(async()=>true);
    a.e(Error, ()=>例外発生コード);
    a.e(new Error('エラーメッセージ'), ()=>例外発生コード);
    a.e(Error, 'エラーメッセージ', ()=>例外発生コード);
    a.e(Error, /^エラーメ/, ()=>例外発生コード);
});
```

## ts/fs/es

　複数形。単体試験において同値分割法があり、複数の値をテストする場合がよくある。このとき、入力値は複数ある。そして出力結果は入力値によって動的に算出できる。ならば次のようなAPIが欲しくなる。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.ts([[第一引数,...], [第一引数,...]], (args, i)=>{
        const res = テスト対象関数(...args);
        return res===args[0]+1; // 戻り値は第一引数+1の値と同じであることを確認する
    });
});
```

　上記は以下テストコード生成と同じである。つまりa.t()をfor()で繰り返し生成することを簡易記法化したもの。

```javascript
unitest('テスト対象ファイル.js', a=>{
    for (let args of [[第一引数,...], [第一引数,...]]) {
        a.t(()=>{
            const res = テスト対象関数(...args);
            return res===args[0]+1;
        });
    }
});
```

## 複数return

　正常系テストで以下のように複数条件確認することが多々有る。このとき、どの条件が失敗したか、その値がいくつだったのかが不明で困る。

```javascript
a.t(()=>{
    return obj.A===1 && obj.B===2;
});
```

　そこでしばしば、以下のような出力をする。

```javascript
a.t(()=>{
    console.log(obj.A===1, obj.B===2); // 何番目がエラーになったか
    console.log(obj.A, obj.B);         // エラーになった値は何を返したのか
    return obj.A===1 && obj.B===2;
});
```

　これにて問題となる実装箇所を特定する。でも毎回このデバッグ出力コードを書くのが面倒くさい。

　そこで、以下のように真偽値の配列として返す。全部真ならテスト合格。一つでも偽なら、そのindexを返せば、何番目の条件式がエラーになったかは判明する。

```javascript
a.t(()=>{
    return [obj.A===1, obj.B===2]; // rets.every(v=>v)が真であること。もし偽ならその箇所を返す。でも`obj`の`A`や`B`が何の値を返すかは不明のまま……
});
```

　だが`obj`の`A`や`B`が何の値を返したかまでは不明なので、問題箇所を特定できない。

### テスト対象の指定

　テスト対象を設定すれば、その値を取得できるはず。以下のように。

```javascript
a.target(context, 'プロパティ名', '期待値');
```

　普通context(文脈)はオブジェクトである。moduleや名前空間として使われ、内部ではthisの値でもある。

```javascript
a.target(obj, 'プロパティ名', '期待値');
```

　次のように参照することで値を取得できる。これでプロパティ名と値の二つを取得できるため、問題が生じた箇所と値を特定する情報を提示できるはず。但しobjの名前は取得できない。

```javascript
obj['プロパティ名']
```

　テストの合否は以下の式で判定できる。

```javascript
'期待値'===obj['プロパティ名']
```

　前回問題だったコードを確認し、それをプロパティ名指定方法で書き換えてみる。

```javascript
a.t(()=>{
    const obj = テストしたい関数();
    return [obj.A===1, obj.B===2]; // rets.every(v=>v)が真であること。もし偽ならその箇所を返す。でも`obj`の`A`や`B`が何の値を返すかは不明のまま……
});
```
```javascript
a.t(()=>{
    const obj = テストしたい関数();
    a.obj(obj, a=>{
        a.prim('A', a=>a.isNum.eq(1));    // プロパティ 'A' は プリミティブNumber 型が期待されましたが プリミティブBoolean 型でした
        a.prim('B', a=>a.isStr.eq('X'));  // プロパティ 'B' は 値 'X' が期待されましたが 'Y' でした。
    });
});
```
```javascript
a.t(()=>{
    const obj = テストしたい関数();
    a.context(obj, a=>{
        a.prop('A', a=>a.isNum.eq(1));    // プロパティ 'A' は プリミティブNumber 型が期待される。値は 1 が期待される。
        a.prop('B', a=>a.isStr.eq('X'));  // プロパティ 'B' は プリミティブString 型が期待される。値は 'X' が期待される。
    });
});
```

　このときエラーメッセージを出すなら次のようになる。どのオブジェクトに対するプロパティ名かが不明なままだが、`Error.stack`でコード箇所が出るため、それを見れば判明する。これでもう`console.log`でいちいち出力して値を確認しなくても自動的に表示してくれるので楽。

```
プロパティ 'A' の型が違います。
期待値: プリミティブNumber
実際値: プリミティブString

プロパティ 'A' の値が違います。
期待値: 1
実際値: 'aaa'
```

```
型が違います。
箇所: プロパティ 'A'
期待値: プリミティブNumber
実際値: プリミティブString

値が違います。
箇所: プロパティ 'A'
期待値: 1
実際値: 'aaa'
```

　`a.t()`は真偽を返す関数なのでふさわしくない。そこで以下のようにする。

```javascript
unitest.case(a=>{
    const obj = テストしたい関数();
    a.context(obj, a=>{
        a.prop('A', a=>a.isNum.eq(1));    // プロパティ 'A' は プリミティブNumber 型が期待されましたが プリミティブBoolean 型でした
        a.prop('B', a=>a.isStr.eq('X'));  // プロパティ 'B' は 値 'X' が期待されましたが 'Y' でした。
    });
});
```

　結果的にテストコードが冗長化されてしまった。

```javascript
前: obj.A===1
後: a.context(obj, a=>a.prop('A', a=>a.eq(1)));
```

　また`eq()`など比較用APIを作成せねばならず、覚えて利用せねばならないのも面倒。そこでプロパティの値だけを返すようにしてみる。

```javascript
unitest.case(a=>{
    const obj = テストしたい関数();
    a.context(obj, a=>{
        a.prop('A', v=>1===v);    // プロパティ 'A' は 1 であること
        a.prop('B', v=>'X'===v);  // プロパティ 'B' は 'X' であること
        a.prop('C', v=>v instanceof SomeClass);  // プロパティ 'B' は SomeClass のインスタンスであること
    });
});
unitest.case(a=>{...});
unitest.case(a=>{...});
```

```javascript
前: obj.A===1
１: a.context(obj, a=>a.prop('A', a=>a.eq(1)));
２: a.context(obj, a=>a.prop('A', v=>1===v);
```

　但し比較用APIがないため、どう問題だったかは式を見てもらうまで判断できない。つまり実際値は参照できても、期待値は条件式の一部なので取得できない。期待式しか返せない。

```
プロパティ 'A' のテストに失敗しました。
期待式: v=>1===v
実際値: obj['A'] の値
```

　期待式は関数なので文字列化すればそのコード文字列を取得できる。

　以下のように細分化すると、よりよくテストできる。

* context
    * Class
    * Instance
    * Function
    * Descriptor
    * Object
* prop
    * 正常系（戻り値を返すことを期待する）
    * 異常系（例外発生することを期待する）

## cls/fn/obj/prim

　テスト対象を明示することでテスト内容がわかりやすくなる。だが専用APIテストコードを大量に書かねばならない。

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{...});
    a.fn(SomeFunction, a=>{...});
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{
        const ca = a;

        // クラス変数
        a.prop('プロパティ名A', v=>v===1); // クラス変数
        a.prop('プロパティ名B', v=>v instanceof SomeClass && 2===v.someA && 'X'===v.someB); // クラス変数オブジェクト（どこが失敗したか分からなくなる）
        a.prop('プロパティ名B', a=>{ // クラス変数オブジェクト
            return [v instanceof SomeClass, 2===v.someA, 'X'===v.someB]; // 失敗した箇所のindexしか分からない（v.someA,Bの値不明）
        });
        a.prop('プロパティ名B', a=>{ // クラス変数オブジェクト
            a.insOf(SomeClass);
            a.prop('someA', a=>a.eq(2));
            a.prop('someB', a=>a.eq('X'));
        });
        a.prop('プロパティ名C', a=>a.eq(1));

        // クラス変数プロパティはPrimitive／Objectに分離したほうが良い？　でもどちらになるかは状況によって変わる可能性もある。ならpropで統一すべきか。
        a.p('プロパティ名', a=>a.isNum.eq(1));
        a.o('プロパティ名', a=>a.insOf(SomeClass).p('プロパティ名', a=>{}).p('プロパティ名', a=>{}));

        a.d('ディスクリプタ名', a=>a.hasGS); // クラスディスクリプタ
        a.d('ディスクリプタ名', a=>{ // クラスディスクリプタ
            a.hasV.hasG.hasS.hasGS;
            a.v(v=>v==='V');
            a.v(a=>a.prop(...).prop(...));
            a.g(v=>v==='G');
            a.g(a=>a.prop(...).prop(...));
            a.s('代入値', (a,g)=>{
                // a は setter の戻り値
                a.isNum.eq(1);
                a.isObj.prop('someA', a=>a.eq(2));
                // g は 同名 getter の戻り値（場合によっては未定義であり存在しない）
                g.isNum.eq(1);
                g.isObj.prop('someA', a=>a.eq(2));
            });
        });
        a.v('バリュー名', v=>v==='V');
        a.v('バリュー名', a=>a.prop(...).prop(...));
        a.g('ゲッター名', v=>v==='G');
        a.g('ゲッター名', a=>a.prop(...).prop(...));
        a.s('セッター名', '代入値', (a,g)=>{
            // a は setter の戻り値
            a.isNum.eq(1);
            a.isObj.prop('someA', a=>a.eq(2));
            // g は 同名 getter の戻り値（場合によっては未定義であり存在しない）
            g.isNum.eq(1);
            g.isObj.prop('someA', a=>a.eq(2));
        });

        a.m('メソッド名', '戻り値');
        a.m('メソッド名', [第一引数, ...], '戻り値');
        a.m('メソッド名', [第一引数, ...], a=>a.prop('A', a=>{}).prop('B', a=>{}));
        a.m('メソッド名', [第一引数, a.mock(()=>{})], a.spy(context, 'propName'), '戻り値');
        a.m('メソッド名', [第一引数, a.mock(()=>{})], a.spy(context, 'propName'), a=>a.prop('A', a=>{}).prop('B', a=>{}));
        a.m('メソッド名', [第一引数, a.mock(()=>{})], a.spy(context, 'propName'), a=>{
            a.prop('A', a=>{}).prop('B', a=>{});
            a.mocks[0].times(1).args(i, []).ret(i, v);
            a.mocks[0].tests((i,args,ret)=>{
                a.args(i, []);
                a.ret(i, v);
            })
            a.spys[0].times(1).args(i, []).ret(i, v);
            a.spys[0].tests((i,args,ret)=>{
                a.args(i, []);
                a.ret(i, v);
            })
            ca.prop('A', a=>{}); // メソッド実行により同クラスのプロパティが変更されたことを確認する
        });
        a.m('メソッド名', Error);
        a.m('メソッド名', new Error('エラーメッセージ'));
        a.m('メソッド名', Error, 'エラーメッセージ');
        a.m('メソッド名', Error, /^エラーメ/);
        a.m('メソッド名', [第一引数, ...], Error);
        a.m('メソッド名', [第一引数, ...], new Error('エラーメッセージ'));
        a.m('メソッド名', [第一引数, ...], Error, 'エラーメッセージ');
        a.m('メソッド名', [第一引数, ...], Error, /^エラーメ/);

        // メソッド複数形
        a.ms('メソッド名', [[], [第一引数, ...], [第一引数, a.mock(()=>{})]], a.spy(context, 'propName'), ..., (a,args)=>{
            // argsで期待値を生成する式を書く
        });
        a.ms('メソッド名', [[], [第一引数, ...], [第一引数, a.mock(()=>{})]], a.spy(context, 'propName'), ..., Error);

        // メソッド名と引数を切り分ける
        a.m('メソッド名', a=>{
            // 引数なしで実行した時のテスト
            a.a('戻り値の期待値');
            a.a(a=>{
                a.isNum.eq(1);
                a.isObj.p('プロパティ名', a=>a.p('X', a=>a.isNum.eq(2)));
            });
            a.a(Error);
            // 引数ありで実行した時のテスト
            a.a([第一引数, ...], a=>{...});
            a.a([第一引数, a.mock(()=>{})], a.spy(context, 'propName'), a=>{...});
            a.a([第一引数, ...], Error);
        });

        // コンストラクタ・インスタンス
        a.ins(a=>{}); // 引数省略形
        a.ins([第一引数, ...], a=>{ // (a, ins)=>{}も可能
            a.p(...); // プロパティ
            a.d(...); // ディスクリプタ
            a.m(...); // メソッド
        });
        a.ins(Error);
        a.ins(new Error('エラーメッセージ'));
        a.ins(Error, 'エラーメッセージ');
        a.ins(Error, /^エラーメ/);
        a.ins([第一引数, ...], Error);
        a.ins([第一引数, ...], new Error('エラーメッセージ'));
        a.ins([第一引数, ...], Error, 'エラーメッセージ');
        a.ins([第一引数, ...], Error, /^エラーメ/);
    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.fn(SomeFunction, a=>{...});
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.fn(SomeFunction, a=>{
        // 引数なしで実行した時のテスト
        a.a('戻り値の期待値');
        a.a(a=>{
            a.isNum.eq(1);
            a.isObj.p('プロパティ名', a=>a.p('X', a=>a.isNum.eq(2)));
        });
        a.a(Error);
        // 引数ありで実行した時のテスト
        a.a([第一引数, ...], a=>{...});
        a.a([第一引数, a.mock(()=>{})], a.spy(context, 'propName'), a=>{...});
        a.a([第一引数, ...], Error);
    });
});
```

## Primitive/Object

```javascript
class TypedAssertion {
    constructor(v) {this._={v:v, tests:[], typed:null}}
//    constructor(v, o) {this._={o:o ?? window, v:v, tests:[], typed:null}}
//    get isPrim() {this._addCase(()=>this._.v!==Object(this._.v), `型が違います。\n期待値: プリミティブ\n実際値: オブジェクト`); return this;}
//    get isObj() {this._addCase(()=>this._.v!==null && 'object'===typeof this._.v && this._tag.startsWith('[object '), `型が違います。\n期待値: オブジェクト\n実際値: プリミティブ`); return this;}
    get isPrim() {
        this._addCase(()=>this._.v!==Object(this._.v), `型が違います。\n期待値: プリミティブ\n実際値: オブジェクト`); 
        this._.typed = new PrimitiveAssertion(this._.v);
        return this._.typed;
    }
    get isObj() {
        this._addCase(
            ()=>this._.v!==null && 'object'===typeof this._.v && this._tag.startsWith('[object '),
            `型が違います。\n期待値: オブジェクト\n実際値: プリミティブ`);
        this._.typed = new ObjectAssertion(this._.v);
//        this._.typed = new TypedAssertion(this._.v);
        return this._.typed;
    }
    eq(v) {this._addCase(()=>this._.v===v, `値の一致を期待しましたが相違しました。\n期待値: ${v}\n実際値: ${this._.v}`); return this;}
    ne(v) {this._addCase(()=>this._.v!==v, `値の相違を期待しましたが一致しました。値が違います。\n期待値: ${v}\n実際値: ${this._.v}`); return this;}
    _addCase(fn, msg) {
        this._.tests.add({
            test: fn,
            msg: msg,
        });
    }
    _isObjLike(v) {return null!==v && 'object'===typeof v}
    _isPrim(v) {return v!==Object(v)}
    get _tag() {return this.isObj ? Object.prototype.call.toString(this._.v) : this.#primTag(v)} // [object Object], [primitive number.NaN] 等
    get #primTag(v) {
        const t = typeof v;
        return `[primitive ${null===v ? 'null' : ('number'!==t ? t : getNumTag(v))}]`;
    }
    get #numTag(v) {
             if (Number.isNaN(v)) {return 'NaN'}
        else if (Number.POSITIVE_INFINITY===v) {return 'PositiveInfinity'}
        else if (Number.NEGATIVE_INFINITY===v) {return 'NegativeInfinity'}
        else if (Number.isSafeInteger(v)) {return 'SafeInteger'}
        else if (Number.isInteger(v)) {return 'Integer'}
        else {return 'Finite'}
    }
}
```
```javascript
class PrimitiveAssertion extends TypedAssertion {
    constructor(v) {super(v); this._={v:v, tests:[], typed:null}}
    get isUnd() {this._addCase(()=>undefined===this._.v, `型が違います。\n期待値: [primitive null]\n実際値: ${this.tag}`); return this;}
    get isNul() {this._addCase(()=>null===typeof this._.v, `型が違います。\n期待値: [primitive undefined]\n実際値: ${this.tag}`); return this;}
    get isSym() {this._addCase(()=>'symbol'===typeof this._.v, `型が違います。\n期待値: [primitive symbol]\n実際値: ${this.tag}`); return this;}
    get isBln() {this._addCase(()=>'boolean'===typeof this._.v, `型が違います。\n期待値: [primitive number]\n実際値: ${this.tag}`); return new BooleanAssertion(this._.v);}
    get isNum() {this._addCase(()=>'number'===typeof this._.v, `型が違います。\n期待値: [primitive number]\n実際値: ${this.tag}`); return new NumberAssertion(this._.v);}
    get isInt() {this._addCase(()=>'bigint'===typeof this._.v, `型が違います。\n期待値: [primitive number]\n実際値: ${this.tag}`); return new BigIntAssertion(this._.v);}
    get isStr() {this._addCase(()=>'string'===typeof this._.v, `型が違います。\n期待値: [primitive number]\n実際値: ${this.tag}`); return new StringAssertion(this._.v);}
}
```
```javascript
class BooleanAssertion extends TypedAssertion {
    constructor(v) {super(v); this._={v:v, tests:[], typed:null}}
    get isT() {this._addCase(()=>true===this._.v, '値が違います。\n期待値: true\n実際値: ${this._.v}'); return this;}
    get isF() {this._addCase(()=>false===this._.v, '値が違います。\n期待値: false\n実際値: ${this._.v}'); return this;}
}
```
```javascript
class NumberAssertion extends TypedAssertion {
    constructor(v) {super(v); this._={v:v, tests:[], typed:null}}
    get isNaN() {this._addCase(()=>Number.isNaN(this._.v), '値が違います。\n期待値: NaN\n実際値: ${this._.v}'); return this;}
    get isPInf() {this._addCase(()=>Number.POSITIVE_INFINITY===this._.v, '値が違います。\n期待値: Number.POSITIVE_INFINITY\n実際値: ${this._.v}'); return this;}
    get isNInf() {this._addCase(()=>Number.NEGATIVE_INFINITY===this._.v, '値が違います。\n期待値: Number.NEGATIVE_INFINITY\n実際値: ${this._.v}'); return this;}
    get isSafeInt() {this._addCase(()=>Number.isSafeInteger(this._.v), '値が違います。\n期待値: Number.isSafeInteger\n実際値: ${this._.v}'); return this;}
    get isInt() {this._addCase(()=>Number.isInteger(this._.v), '値が違います。\n期待値: Number.isSafeInteger\n実際値: ${this._.v}'); return this;}
    get isFinite() {this._addCase(()=>Number.isFinite(this._.v), '値が違います。\n期待値: Number.isFinite\n実際値: ${this._.v}'); return this;}
    l(v) {
        if ('number'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はnumberであるべきです。`)}
        this._addCase(()=>this._.v < v, `値が範囲を超過しています。期待値: ${v} より小さい\n実際値: ${this._.v}`);
        return this;
    }
    le(v) {
        if ('number'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はnumberであるべきです。`)}
        this._addCase(()=>this._.v <= v, `値が範囲を超過しています。期待値: ${v} 以下\n実際値: ${this._.v}`);
        return this;
    }
    g(v) {
        if ('number'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はnumberであるべきです。`)}
        this._addCase(()=>v < this._.v, `値が範囲を超過しています。期待値: ${v} より大きい\n実際値: ${this._.v}`);
        return this;
    }
    ge(v) {
        if ('number'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はnumberであるべきです。`)}
        this._addCase(()=>v <= this._.v, `値が範囲を超過しています。期待値: ${v} 以上\n実際値: ${this._.v}`);
        return this;
    }
    within(min, max) {
        if (![min, max].every(v=>'number'===typeof v)) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は両方共numberであるべきです。`)}
        if (max <= min) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は min < max であるべきです。`)}
        this._addCase(()=>min <= this._.v && this._.v <= max, `値が範囲を超過しています。期待値: ${min}〜${max}の内\n実際値: ${this._.v}`);
        return this;
    }
    without(min, max) {
        if (![min, max].every(v=>'number'===typeof v)) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は両方共numberであるべきです。`)}
        if (max <= min) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は min < max であるべきです。`)}
        this._addCase(()=>this._.v <= min && max <= this._.v, `値が範囲内に収まりました。期待値: ${min}〜${max}の外\n実際値: ${this._.v}`);
        return this;
    }
}
```
```javascript
class BigIntAssertion extends TypedAssertion {
    constructor(v) {super(v); this._={v:v, tests:[], typed:null}}
    l(v) {
        if ('bigint'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はbigintであるべきです。`)}
        this._addCase(()=>this._.v < v, `値が範囲を超過しています。期待値: ${v} より小さい\n実際値: ${this._.v}`);
        return this;
    }
    le(v) {
        if ('bigint'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はbigintであるべきです。`)}
        this._addCase(()=>this._.v <= v, `値が範囲を超過しています。期待値: ${v} 以下\n実際値: ${this._.v}`);
        return this;
    }
    g(v) {
        if ('bigint'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はbigintであるべきです。`)}
        this._addCase(()=>v < this._.v, `値が範囲を超過しています。期待値: ${v} より大きい\n実際値: ${this._.v}`);
        return this;
    }
    ge(v) {
        if ('bigint'!==typeof v) {throw new TestError(`テストケース作成に失敗しました。l(v)の引数はbigintであるべきです。`)}
        this._addCase(()=>v <= this._.v, `値が範囲を超過しています。期待値: ${v} 以上\n実際値: ${this._.v}`);
        return this;
    }
    within(min, max) {
        if (![min, max].every(v=>'bigint'===typeof v)) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は両方共bigintであるべきです。`)}
        if (max <= min) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は min < max であるべきです。`)}
        this._addCase(()=>min <= this._.v && this._.v <= max, `値が範囲を超過しています。期待値: ${min}〜${max}の内\n実際値: ${this._.v}`);
        return this;
    }
    without(min, max) {
        if (![min, max].every(v=>'bigint'===typeof v)) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は両方共bigintであるべきです。`)}
        if (max <= min) {throw new TestError(`テストケース作成に失敗しました。within(min, max)の引数は min < max であるべきです。`)}
        this._addCase(()=>this._.v <= min && max <= this._.v, `値が範囲内に収まりました。期待値: ${min}〜${max}の外\n実際値: ${this._.v}`);
        return this;
    }
}
```
```javascript
class StringAssertion extends TypedAssertion {
    constructor(v) {super(v); this._={v:v, tests:[], typed:null}}
    length(...args) {return this.#size(this._.v.length, ...args)}
    graphemes(...args) {return this.#size(Array.from(this._.v).length, ...args)}
    #size(size, ...args) {
        if (1===args.length && Number.isSafeInteger(args[0])) {
            this._addCase(()=>size===args[0], `文字列の長さが期待値と異なります。\n期待値: ${args[0]}\n実際値: ${size}`);
        } else if (2===args.length && args.every(v=>Number.isSafeInteger(v))) {
            this._addCase(()=>args[0] <= size && size <= args[1], `文字列の長さが期待値する範囲外です。\n期待値: ${args[0]}〜${args[1]}以内\n実際値: ${size}`);
        } else {throw new TestError(`テスト定義中に例外発生しました。length()の引数は1〜2個のNumber.isSafeInteger()値であるべきです。`)}
        return this;
    }
    startsWith(v) {
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。startsWith(v)の引数はString値であるべきです。`)}
        this._addCase(()=>this._.v.startsWith(v), `文字列の先頭が期待値と一致しませんでした。\n期待値: ${v}\n実際値: ${this._.v}`);
        return this;
    }
    endsWithv(v) {
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。startsWith(v)の引数はString値であるべきです。`)}
        this._addCase(()=>this._.v.endsWith(v), `文字列の末尾が期待値と一致しませんでした。\n期待値: ${v}\n実際値: ${this._.v}`);
        return this;
    }
    with(v) {
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。startsWith(v)の引数はString値であるべきです。`)}
        this._addCase(()=>-1 < this._.v.indexOf(v), `期待する部分文字列が含まれていませんでした。\n期待値: ${v}\n実際値: ${this._.v}`);
        return this;
    }
    match(v) {
        if (v instanceof RegExp) {throw new TestError(`テイスト定義中に例外発生しました。match(v)の引数はRegExp値であるべきです。`)}
        this._addCase(()=>this._.v.match(v), `期待する正規表現にマッチしませんでした。\n期待値: ${v}\n実際値: ${this._.v}`);
        return new RegExpAssertion(this._.v.match());
    }
}
```
```javascript
class RegExpAssertion extends TypedAssertion {
    constructor(v,r) {
        super(v);
        this._={v:v, tests:[], typed:null, r:r}
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。new RegExpAssertion(v,r)の引数vはString値であるべきです。`)}
        if (r instanceof RegExp) {throw new TestError(`テイスト定義中に例外発生しました。new RegExpAssertion(v,r)の引数rはRegExp値であるべきです。`)}
        this._.m = this._.v.match(this._.r);
//        if (!this._.m) {throw new TestError(`テイスト定義中に例外発生しました。new RegExpAssertion(v,r)の文字列vは正規表現rにマッチしません。`)}
    }
    allText(v) {
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。allText(v)の引数はString値であるべきです。`)}
        this._addCase(()=>v===this._.m[0], `マッチした文字列の全文は期待値と一致しませんでした。\n期待値: ${v}\n実際値: ${this._.m[0]}`);
        return this;
    }
    idxEq(i, v) {
        if (!Number.isSafeInteger(i)) {throw new TestError(`テイスト定義中に例外発生しました。idxEq(i, v)の引数iはNumber値であるべきです。`)}
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。idxEq(i, v)の引数vはString値であるべきです。`)}
        this._addCase(()=>v===this._.m[i], `マッチした文字列の部分は期待値と一致しませんでした。\n期待値: ${i}:${v}\n実際値: ${this._.m[i]}`);
        return this;
    }
    groupEq(n, v) {
        if ('string'!==typeof n) {throw new TestError(`テイスト定義中に例外発生しました。groupEq(n, v)の引数nはString値であるべきです。`)}
        if ('string'!==typeof v) {throw new TestError(`テイスト定義中に例外発生しました。groupEq(n, v)の引数vはString値であるべきです。`)}
        this._addCase(()=>v===this._.m.group[n], `マッチした文字列の部分は期待値と一致しませんでした。\n期待値: ${n}:${v}\n実際値: ${this._.m[i]}`);
        return this;
    }
}
```
```javascript
class ObjectAssertion extends TypedAssertion {
    constructor(o) {this._={o:o, tests:[]}}
    //constructor(o,p) {this._={o:o, p:p, v:v, tests:[]}}
    p(n, fnOrV) {
        this._addCase(()=>n in this._.o, `期待されたプロパティがありません。`);
        const v = this._.o[n];
        if (isFn(fnOrV)) {
            const a = this._isObjLike(v) ? new ObjectAssertion(v) : new PrimitiveAssertion(v);
            fnOrV(a);
        }
        else {this._addCase(()=>fnOrV===this._.o[n], `プロパティの値は期待値と一致しませんでした。\n期待値: ${n}:${fnOrV}\n実際値: ${v}`);}
        return this;
    }
    isCls() {

    }
    isIns() {}
    isErrCls() {}
    isErrIns() {}
    isD() {}// ディスクリプタ
}
```
```javascript
class DescriptorAssertion extends TypedAssertion {
    constructor(o,n) {this._={o:o, n:n, v:v, tests:[]}}
    get hasV() {
        // this._isObjLike(this._.o[this._.n])
        this._addCase(()=>'value' in this._.o[this._.n] && ['get','set'].every(v=>!(v in this._.o[this._.n])), `データディスクリプタではありませんでした。`);
    }
    get hasG() {
        this._addCase(()=>'get' in this._.o[this._.n] && ['value','set'].every(v=>!(v in this._.o[this._.n])), `ゲッターのみを期待しましたが違います。`);
    }
    get hasS() {
        this._addCase(()=>'set' in this._.o[this._.n] && ['value','get'].every(v=>!(v in this._.o[this._.n])), `セッターのみを期待しましたが違います。`);
    }
    get hasGS() {
        this._addCase(()=>['get','set'].every(v=>v in this._.o) && !('value' in this._.o[this._.n]) && , `ゲッターとセッターを期待しましたが違います。`);
    }
    v(expected) {
        const actual = Reflect.get(this._.o, this._.n);
        if (isFn(expected)) {expected(this._isObjLike(actual) ? new ObjectAssertion(actual) : new PrimitiveAssertion(actual))}
        else {this._addCase(()=>expected===actual, `ゲッター ${this._.n} の値は期待値と一致しませんでした。\n期待値: ${expected}\n実際値: ${actual}`);}
        return this;
    }
    g(expected) {
        const actual = Reflect.get(this._.o, this._.n);
        if (isFn(expected)) {expected(this._isObjLike(actual) ? new ObjectAssertion(actual) : new PrimitiveAssertion(actual))}
        else {this._addCase(()=>expected===actual, `ゲッター ${this._.n} の値は期待値と一致しませんでした。\n期待値: ${expected}\n実際値: ${actual}`);}
        return this;
    }
    s(v, expected) {
        const actual = Reflect.set(this._.o, this._.n, v);
        const g = Reflect.get(this._.o, this._.n);
        if (isFn(expected)) {expected(this._isObjLike(g) ? new ObjectAssertion(g) : new PrimitiveAssertion(g))}
        else {this._addCase(()=>expected===actual, `ゲッター ${this._.n} の値は期待値と一致しませんでした。\n期待値: ${expected}\n実際値: ${actual}`);}
        return this;
    }
}
```



    a.obj(SomeObject, a=>{...});
    a.prim(somePrimitive, a=>{...});

```javascript
unitest('テスト対象ファイル.js', a=>{
    a.prim(somePrimitive, a=>{
        // 型
        a.type.isBln;
        a.type.isNum;
        a.type.isInt;
        a.type.isStr;
        a.type.isSym;
        a.type.isNul;
        a.type.isUnd;
        // 値
        //   Null,Undefined,Symbol
        a.value.isNul; // typeと同じで別名
        a.value.isUnd; // typeと同じで別名
        a.value.eq(期待値); // Bln,Num,Int,Str,Sym
        //   Boolean
        a.value.isT;
        a.value.isF;
        //   Number/BigInt
        a.value.ne(この値と一致しないこと);
        a.value.l(これより小さいこと);
        a.value.g(これより大きいこと);
        a.value.le(これより小さいこと);
        a.value.ge(これより大きいこと);
        a.value.within(最小値, 最大値);
        a.value.without(最小値, 最大値);
        //   Number
        a.value.isNaN;
        a.value.isNotNaN;
        a.value.isPInf;
        a.value.isNInf;
        a.value.isNotPInf;
        a.value.isNotNInf;
        a.value.isSafeInt(期待値);
        a.value.nearEq(IEEE754誤差を考慮した比較);
        //   String
        a.value.length(バイト数);  // (最小値, 最大値)
        a.value.graphemes(文字数); // (最小値, 最大値)
        a.value.eq('完全一致する期待値');
        a.value.startsWith('前方一致する期待値');
        a.value.endsWith('後方一致する期待値');
        a.value.with('部分一致する期待値');
        a.value.match(/正規表現/);
    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.obj(SomeObject, a=>{
        a.isCls;
        a.isIns;
        a.isErrCls;
        a.isErrIns;
        a.isFnLike;
        a.isAFnLike;
        a.isGFnLike;
        a.isFn;
        a.isAFn;
        a.isGFn;
        a.isAGFn;
        a.isObjLike; // 'object'===typeof v && null!==v
        a.isObj;     // [object Object]
        a.clsOf(SomeClass);
        a.insOf(SomeClass);
        a.isAry;
        a.aryOf('number'/'ClassName');
        a.tag('Array'); // [object Array]である
        a.isD;  // Descriptor
        a.isDD; // DataDescriptor（value）
        a.isAD; // AccessorDescriptor (Getter || Setter)
        a.isG;  // Getterのみ
        a.isS;  // Setterのみ
        a.isGS; // GetterとSetterの両方ある
        a.t(()=>true); // 任意のテスト式でtrueを返すこと
        a.e(()=>true); // 任意のテスト式で例外発生すること
        a.prim('プロパティ名', a=>{}); // Object内のプロパティ
        a.obj('プロパティ名', a=>{}); // Object内のプロパティ
    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.fn(SomeFunction, a=>{
        a.a([第一引数, ...], '戻り値の期待値プリミティブ');
        a.a([第一引数, ...], a=>{
            a.prim();
            a.obj();
        });
        a.a([第一引数, a.mock(()=>{}), ...], a.spy(obj,'prop'), ..., a=>{
            a.prim();
            a.obj();
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fns(SomeFunction, a=>{
        a.s([[], [第一引数, ...], [a.mock(()=>{}), ...], ...], a.spy(obj,'prop'), ..., a=>{
            a.prim();
            a.obj();
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fe(SomeFunction, a=>{
        // 引数なし
        a.e(Error);
        a.e('メッセージ');
        a.e(/メッセ/);
        a.e(new Error('メッセージ'));
        a.e(Error, 'メッセージ');
        a.e(Error, /メッセ/);
        // 引数あり
        a.a([第一引数, ...], Error);
        a.a([第一引数, ...], 'メッセージ');
        a.a([第一引数, ...], /メッセ/);
        a.a([第一引数, ...], new Error('メッセージ'));
        a.a([第一引数, ...], Error, 'メッセージ');
        a.a([第一引数, ...], Error, /メッセ/);
        // 引数, Mock, Spyあり
        a.a([第一引数, a.mock(()=>{}), ...], a.spy(obj,'prop'), ..., a=>{
            // 戻り値の確認
            a.prim();
            a.obj();
            // Mock, Spyの確認
            a.mock[0].times(1);
            a.mock[0].args(index, [第一引数, ...]);
            a.mock[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.mock[0].ret(index, '期待値');
            a.mock[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
            a.spy[0].times(1);
            a.spy[0].args(index, [第一引数, ...]);
            a.spy[0].args(index, (a, args)=>{
                a.obj(args[0], a=>{a.insOf(SomeClass)});
            });
            a.spy[0].ret(index, '期待値');
            a.spy[0].ret(index, (a, ret)=>{
                a.obj(a=>{a.insOf(SomeClass)});
            });
        });
    });
    a.fes(SomeFunction, a=>{

    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{
        
    });
    a.fn(SomeFunction, a=>{

    });
    a.obj(SomeObject, a=>{

    });
    a.prim(somePrimitive, a=>{

    });
});
```
```javascript
unitest('テスト対象ファイル.js', a=>{
    a.cls(SomeClass, a=>{
        
    });
    a.fn(SomeFunction, a=>{

    });
    a.obj(SomeObject, a=>{

    });
    a.prim(somePrimitive, a=>{

    });
});
```

```javascript
class 
```



# 単体試験 テストケース 作り方 ヌケモレがないか

## AI による概要

　単体テストのテストケース作成において抜け漏れを防ぐには、体系的なテスト設計技法の活用と、明確なテスト観点の設定が重要です。以下に具体的な方法を示します。 

### 1. テストケース作成の基本手順

    テスト対象の明確化: まず、どの機能やモジュールをテストするのか、その範囲と目的を明確にします。
    テスト観点の洗い出し: テスト対象の機能や仕様書から、「何をテストすべきか」という観点を洗い出します。
        機能要素: どのような機能があるか。
        入力条件: どのような入力値が許容されるか、またはされないか。
        出力結果: 入力に対してどのような結果（正常な値、エラーメッセージなど）が期待されるか。
    テスト技法の適用: 洗い出した観点に基づき、効率よく網羅的なテストケースを作成するために以下の技法を適用します。
    テストケースの記述: 「テスト対象」「テスト観点」「テスト条件」「テスト手順」「期待値」といった必要な項目を明確に記述します。 

### 2. 抜け漏れを防ぐためのテスト技法

効率的かつ網羅的にテストケースを作成するには、以下の技法を組み合わせます。 

    同値分割法: 有効な入力値の範囲をいくつかのグループ（同値クラス）に分け、各グループから代表値を選んでテストします。例えば、年齢が「0～120」歳の場合、「有効値（10歳）」と「無効値（-1歳、121歳）」のように分割します。
    境界値分析法: 同値分割した境界となる値やその前後の値をテストします。上記の例では、「0歳、1歳」「119歳、120歳」などをテストします。
    異常値分析: 仕様外の無効な値（例: マイナス値、全角文字、記号など）を入力し、適切なエラーハンドリングがされるかを確認します。
    デシジョンテーブル（決定表）: 複数の条件の組み合わせによって動作が変わる場合に、すべての組み合わせとその結果を網羅的にリストアップします。 

### 3. 網羅性チェックのための戦略

    コードカバレッジの活用: 実際にテストケースを実行し、どの程度のコードが実行されたかを測定します（行カバレッジ、分岐カバレッジなど）。これにより、テストされていないコード部分を特定し、追加のテストケースを作成できます。
    第三者によるレビュー: 作成したテストケースを他の開発者やテスターにレビューしてもらうことで、個人の先入観による抜け漏れを防げます。
    チェックリストの利用: フォームの入力項目、データベースの操作、例外処理など、一般的なテスト観点をまとめたチェックリストを用意しておくと、確認漏れを減らせます。
    過去の不具合事例を参考にする: 過去のプロジェクトで発生したバグや不具合の事例を参考に、同様の問題が発生しないようなテストケースを事前に組み込みます。 

これらの体系的なアプローチにより、単体テストにおけるテストケースの抜け漏れを大幅に減らし、ソフトウェアの品質向上につながります。 
